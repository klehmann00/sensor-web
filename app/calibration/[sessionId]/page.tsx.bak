// app/calibration/[sessionId]/page.tsx
'use client';

import { useEffect, useState, useMemo } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { useAuth } from '@/lib/hooks/useAuth';
import { useAdmin } from '@/contexts/AdminContext';
import StorageManager from '@/lib/managers/StorageManager';
import { database } from '@/lib/firebase';
import AccelerometerChart from '@/components/sensors/AccelerometerChart';
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
  Filler
} from 'chart.js';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
  Filler
);

interface Vector3D {
  x: number;
  y: number;
  z: number;
  timestamp?: number;
}

interface GPSData {
  mph: number;
  kph: number;
  mps: number;
  timestamp: number;
}

interface SessionDetail {
  sessionId: string;
  startTime: number;
  endTime?: number;
  status: string;
  accelerometerData: Vector3D[];
  gyroscopeData: Vector3D[];
  magnetometerData: Vector3D[];
  gpsData: GPSData[];
}

/**
 * Apply exponential moving average filter to smooth noisy data.
 * Used for orientation learning to correlate GPS with sensor data.
 * Does NOT affect final transformed data - only used for direction detection.
 *
 * EMA formula: filtered[i] = alpha * data[i] + (1 - alpha) * filtered[i-1]
 *
 * @param data - Array of values to filter
 * @param alpha - Smoothing factor (0-1). Lower = more smoothing.
 *                0.05 = heavy smoothing, 0.5 = moderate, 0.95 = minimal
 * @returns Filtered array (same length as input)
 */
function exponentialMovingAverage(data: number[], alpha: number): number[] {
  if (data.length === 0) return [];

  const result: number[] = [];
  let smoothed = data[0]; // Initialize with first value

  for (let i = 0; i < data.length; i++) {
    smoothed = alpha * data[i] + (1 - alpha) * smoothed;
    result.push(smoothed);
  }

  return result;
}

interface CalibrationResult {
  transformed: Vector3D[];
  gravityHistory: Vector3D[];
  forwardHistory: Vector3D[];
  confidence: number[];
  gpsAccelDetected: boolean[];
  turningDetected: boolean[];
  forwardUpdateCount: number[];
  virtualForwardAccel: number[];
  virtualLateralAccel: number[];
  actualSampleRate: number;
  // Cross-verification trifecta
  accelLinearY_observed: number[];
  observerAccelLinearY_fromGyro: number[];
  observerAccelLinearY_fromMag: number[];
  gyroFilteredZ_observed: number[];
  observerGyroZ_fromAccel: number[];
  observerGyroZ_fromMag: number[];
  heading_observed: number[];
  observerHeading_fromAccel: number[];
  observerHeading_fromGyro: number[];
}

/**
 * FILTERING STRATEGY (Exponential Moving Average - EMA):
 * - Orientation learning uses EMA-FILTERED data (GPS + sensors) to find correlation
 * - Vehicle transformation uses UNFILTERED data for accuracy
 * - EMA removes high-frequency noise (vibrations) to reveal true acceleration events
 * - Filter strength adjustable via UI (alpha: 0.01-0.95, default 0.05 = heavy smoothing)
 * - EMA formula: filtered[i] = Î± * data[i] + (1-Î±) * filtered[i-1]
 */
// Helper function for GPS interpolation
function interpolateGPSData(gpsData: GPSData[], targetLength: number): GPSData[] {
  if (gpsData.length === 0) {
    return Array(targetLength).fill({ mph: 0, kph: 0, mps: 0, timestamp: 0 });
  }

  if (gpsData.length === targetLength) {
    return gpsData;
  }

  const interpolated: GPSData[] = [];
  for (let i = 0; i < targetLength; i++) {
    const gpsRatio = (i / targetLength) * gpsData.length;
    const prevIndex = Math.floor(gpsRatio);
    const nextIndex = Math.min(prevIndex + 1, gpsData.length - 1);

    if (prevIndex === nextIndex) {
      interpolated.push(gpsData[prevIndex]);
    } else {
      const ratio = gpsRatio - prevIndex;
      const prevGPS = gpsData[prevIndex];
      const nextGPS = gpsData[nextIndex];
      interpolated.push({
        mph: prevGPS.mph + (nextGPS.mph - prevGPS.mph) * ratio,
        kph: prevGPS.kph + (nextGPS.kph - prevGPS.kph) * ratio,
        mps: prevGPS.mps + (nextGPS.mps - prevGPS.mps) * ratio,
        timestamp: i
      });
    }
  }
  return interpolated;
}

function applyFloatingCalibration(
  accelData: Vector3D[],
  gyroData: Vector3D[],
  gpsData: GPSData[],
  alpha: number = 0.95,
  observerAlpha: number = 0.05
): CalibrationResult {
  const result: CalibrationResult = {
    transformed: [],
    gravityHistory: [],
    forwardHistory: [],
    confidence: [],
    gpsAccelDetected: [],
    turningDetected: [],
    forwardUpdateCount: [],
    virtualForwardAccel: [],
    virtualLateralAccel: [],
    actualSampleRate: 60,
    // Cross-verification trifecta
    accelLinearY_observed: [],
    observerAccelLinearY_fromGyro: [],
    observerAccelLinearY_fromMag: [],
    gyroFilteredZ_observed: [],
    observerGyroZ_fromAccel: [],
    observerGyroZ_fromMag: [],
    heading_observed: [],
    observerHeading_fromAccel: [],
    observerHeading_fromGyro: []
  };

  // State variables
  let gravity = { x: 0, y: 0, z: 0 };
  let forward = { x: 0, y: 0, z: 0 };
  let prevSpeed = 0;
  let prevHeading = 0;
  let totalForwardUpdates = 0;

  // Cross-verification trifecta state
  let integratedHeading_accel = 0;
  let integratedHeading_gyro = 0;
  let prevMagHeading = 0;

  // === FILTERED SIGNALS FOR OBSERVERS (noise reduction) ===
  // Filter LINEAR acceleration (after gravity removal), not raw accel
  let filteredLinearAccelX = 0, filteredLinearAccelY = 0, filteredLinearAccelZ = 0;
  let filteredGyroX = 0, filteredGyroY = 0, filteredGyroZ = 0;
  let filteredMagHeading = 0;

  const SAMPLE_RATE = 60;
  const deltaTime = 1 / SAMPLE_RATE;

  // Interpolate GPS data to match accelerometer sample rate
  const interpolatedGPS = interpolateGPSData(gpsData, accelData.length);

  // Main processing loop
  for (let i = 0; i < accelData.length; i++) {
    const accel = accelData[i];
    const gyro = gyroData[i] || { x: 0, y: 0, z: 0 };
    const gps = interpolatedGPS[i];

    // === STEP 1: GRAVITY TRACKING ===
    // Use faster gravity filter (alpha = 0.7) to avoid capturing turn forces
    // Slower filter (0.95) was lagging 0.33s and including centripetal acceleration
    const gravityAlpha = 0.7;
    gravity.x = gravityAlpha * gravity.x + (1 - gravityAlpha) * accel.x;
    gravity.y = gravityAlpha * gravity.y + (1 - gravityAlpha) * accel.y;
    gravity.z = gravityAlpha * gravity.z + (1 - gravityAlpha) * accel.z;

    // === STEP 2: REMOVE GRAVITY FIRST (from raw data) ===
    const linearAccel = {
      x: accel.x - gravity.x,
      y: accel.y - gravity.y,
      z: accel.z - gravity.z
    };

    // Debug logging for turn section (samples 2800-2810)
    if (i >= 2800 && i <= 2810) {
      const gravityMag = Math.sqrt(gravity.x**2 + gravity.y**2 + gravity.z**2);
      console.log('\n\n=== SAMPLE ' + i + ' GRAVITY DEBUG ===');
      console.log('  Raw Accel:', {
        x: accel.x.toFixed(3),
        y: accel.y.toFixed(3),
        z: accel.z.toFixed(3)
      });
      console.log('  Gravity Est:', {
        x: gravity.x.toFixed(3),
        y: gravity.y.toFixed(3),
        z: gravity.z.toFixed(3),
        mag: gravityMag.toFixed(3)
      });
      console.log('  Linear Accel:', {
        x: linearAccel.x.toFixed(3),
        y: linearAccel.y.toFixed(3),
        z: linearAccel.z.toFixed(3)
      });
      console.log('==================\n');
    }

    // === STEP 3: FILTER THE LINEAR ACCELERATION (gravity already removed) ===
    // This is the KEY FIX: filter the linear accel, not the raw accel!
    filteredLinearAccelX = observerAlpha * linearAccel.x + (1 - observerAlpha) * filteredLinearAccelX;
    filteredLinearAccelY = observerAlpha * linearAccel.y + (1 - observerAlpha) * filteredLinearAccelY;
    filteredLinearAccelZ = observerAlpha * linearAccel.z + (1 - observerAlpha) * filteredLinearAccelZ;

    const filteredLinearAccel = {
      x: filteredLinearAccelX,
      y: filteredLinearAccelY,
      z: filteredLinearAccelZ
    };

    // === STEP 4: FILTER GYRO (unchanged) ===
    filteredGyroX = observerAlpha * gyro.x + (1 - observerAlpha) * filteredGyroX;
    filteredGyroY = observerAlpha * gyro.y + (1 - observerAlpha) * filteredGyroY;
    filteredGyroZ = observerAlpha * gyro.z + (1 - observerAlpha) * filteredGyroZ;

    // === STEP 2: CALCULATE VIRTUAL ACCELERATIONS ===
    const currentSpeed = gps.mps;
    const virtualForwardAccel = (currentSpeed - prevSpeed) / deltaTime;
    prevSpeed = currentSpeed;

    const rotationRate = gyro.z;
    const virtualLateralAccel = currentSpeed * rotationRate;

    result.virtualForwardAccel.push(virtualForwardAccel);
    result.virtualLateralAccel.push(virtualLateralAccel);

    // === STEP 3: CROSS-VERIFICATION TRIFECTA (using FILTERED signals) ===
    // Each sensor verified by the other two
    // Note: currentSpeed and rotationRate already defined above

    // Calculate magnetometer heading (atan2 of horizontal components) and filter it
    // Assuming mag.x = North, mag.y = East
    const mag = gyroData[i] || { x: 0, y: 0, z: 0 }; // TODO: Use actual magnetometer data
    const rawMagHeading = Math.atan2(mag.y, mag.x); // radians
    filteredMagHeading = observerAlpha * rawMagHeading + (1 - observerAlpha) * filteredMagHeading;

    // Calculate heading change rate from FILTERED magnetometer
    const magHeadingRate = i > 0 ? (filteredMagHeading - prevMagHeading) / deltaTime : 0;
    prevMagHeading = filteredMagHeading;


    // === LATERAL ACCELERATION TRIFECTA (using FILTERED signals) ===
    // 1. Measured from FILTERED accelerometer (after removing gravity)
    const accelLinearY_observed = filteredLinearAccel.y;

    // 2. Predicted from FILTERED gyroscope (centripetal acceleration: a = v*Ï‰)
    const observerAccelLinearY_fromGyro = currentSpeed * filteredGyroZ;

    // 3. Predicted from FILTERED magnetometer (heading change â†’ rotation rate â†’ centripetal accel)
    const observerAccelLinearY_fromMag = currentSpeed * magHeadingRate;

    result.accelLinearY_observed.push(accelLinearY_observed);
    result.observerAccelLinearY_fromGyro.push(observerAccelLinearY_fromGyro);
    result.observerAccelLinearY_fromMag.push(observerAccelLinearY_fromMag);

    // === ROTATION RATE TRIFECTA (using FILTERED signals) ===
    // 1. Measured from FILTERED gyroscope
    const gyroFilteredZ_observed = filteredGyroZ;

    // 2. Predicted from FILTERED accelerometer (Ï‰ = a/v, from centripetal acceleration)
    const observerGyroZ_fromAccel = currentSpeed > 1 ? (filteredLinearAccel.y / currentSpeed) : 0;

    // 3. Predicted from FILTERED magnetometer (heading change rate)
    const observerGyroZ_fromMag = magHeadingRate;

    result.gyroFilteredZ_observed.push(gyroFilteredZ_observed);
    result.observerGyroZ_fromAccel.push(observerGyroZ_fromAccel);
    result.observerGyroZ_fromMag.push(observerGyroZ_fromMag);

    // === HEADING TRIFECTA (integrated from FILTERED rates) ===
    // 1. Measured from FILTERED magnetometer
    const heading_observed = filteredMagHeading;

    // 2. Predicted from accelerometer (integrate FILTERED observerGyroZ_fromAccel)
    integratedHeading_accel += observerGyroZ_fromAccel * deltaTime;
    const observerHeading_fromAccel = integratedHeading_accel;

    // 3. Predicted from gyroscope (integrate FILTERED gyroZ)
    integratedHeading_gyro += filteredGyroZ * deltaTime;
    const observerHeading_fromGyro = integratedHeading_gyro;

    result.heading_observed.push(heading_observed * 180 / Math.PI); // Convert to degrees
    result.observerHeading_fromAccel.push(observerHeading_fromAccel * 180 / Math.PI);
    result.observerHeading_fromGyro.push(observerHeading_fromGyro * 180 / Math.PI);

    // === STEP 4: FORWARD DIRECTION LEARNING (Simplified) ===
    // Use GPS-based acceleration for forward learning
    const significantAccel = Math.abs(virtualForwardAccel) > 0.2; // m/sÂ²

    if (significantAccel) {
      forward.x = alpha * forward.x + (1 - alpha) * linearAccel.x;
      forward.y = alpha * forward.y + (1 - alpha) * linearAccel.y;
      forward.z = alpha * forward.z + (1 - alpha) * linearAccel.z;
      totalForwardUpdates++;
    }

    // === STEP 5: ORTHOGONALIZE FUSED FORWARD ===
    const gravityMag = Math.sqrt(gravity.x**2 + gravity.y**2 + gravity.z**2);
    if (gravityMag > 0.1 && totalForwardUpdates > 0) {
      const gravityNorm = {
        x: gravity.x / gravityMag,
        y: gravity.y / gravityMag,
        z: gravity.z / gravityMag
      };
      const dot = forward.x * gravityNorm.x + forward.y * gravityNorm.y + forward.z * gravityNorm.z;
      forward.x -= dot * gravityNorm.x;
      forward.y -= dot * gravityNorm.y;
      forward.z -= dot * gravityNorm.z;
    }

    // === STEP 6: CALCULATE CONFIDENCE ===
    const gravityMagnitude = gravityMag;
    const forwardMagnitude = Math.sqrt(forward.x**2 + forward.y**2 + forward.z**2);

    const gravityConfidence = Math.min(1, gravityMagnitude / 9.8);
    const forwardConfidence = Math.min(1, forwardMagnitude / 0.5);

    const confidence = (gravityConfidence + forwardConfidence) / 2;

    // === STEP 7: TRANSFORM TO VEHICLE COORDINATES ===
    const gravityNorm = Math.sqrt(gravity.x**2 + gravity.y**2 + gravity.z**2);
    const forwardNorm = Math.sqrt(forward.x**2 + forward.y**2 + forward.z**2);

    let down = { x: 0, y: 0, z: 1 };
    let forwardDir = { x: 1, y: 0, z: 0 };

    if (gravityNorm > 0.1) {
      down = {
        x: gravity.x / gravityNorm,
        y: gravity.y / gravityNorm,
        z: gravity.z / gravityNorm
      };
    }

    if (forwardNorm > 0.1) {
      forwardDir = {
        x: forward.x / forwardNorm,
        y: forward.y / forwardNorm,
        z: forward.z / forwardNorm
      };
    }

    // Calculate lateral (cross product: forward Ã— down)
    const lateral = {
      x: forwardDir.y * down.z - forwardDir.z * down.y,
      y: forwardDir.z * down.x - forwardDir.x * down.z,
      z: forwardDir.x * down.y - forwardDir.y * down.x
    };

    // Transform to vehicle coordinates
    const transformed = {
      x: linearAccel.x * forwardDir.x + linearAccel.y * forwardDir.y + linearAccel.z * forwardDir.z,
      y: linearAccel.x * lateral.x + linearAccel.y * lateral.y + linearAccel.z * lateral.z,
      z: linearAccel.x * down.x + linearAccel.y * down.y + linearAccel.z * down.z,
      timestamp: accel.timestamp
    };

    // Store results
    result.transformed.push(transformed);
    result.gravityHistory.push({ ...gravity, timestamp: accel.timestamp });
    result.forwardHistory.push({ ...forward, timestamp: accel.timestamp });
    result.confidence.push(confidence);
    result.gpsAccelDetected.push(significantAccel);
    result.turningDetected.push(Math.abs(rotationRate) > 0.1); // Turning if rotation > 0.1 rad/s
    result.forwardUpdateCount.push(totalForwardUpdates);
  }

  // Calculate actual sample rate
  if (accelData.length > 1 && accelData[0].timestamp && accelData[accelData.length - 1].timestamp) {
    const totalTimeMs = accelData[accelData.length - 1].timestamp! - accelData[0].timestamp!;
    const totalTimeSeconds = totalTimeMs / 1000;
    if (totalTimeSeconds > 0) {
      result.actualSampleRate = (accelData.length - 1) / totalTimeSeconds;
    }
  }


  return result;
}

export default function CalibrationAnalysisPage() {
  const router = useRouter();
  const params = useParams();
  const sessionId = params.sessionId as string;
  const { user, loading } = useAuth();
  const { isAdmin } = useAdmin();
  const [session, setSession] = useState<SessionDetail | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [alpha, setAlpha] = useState(0.95);
  const [orientationFilterAlpha, setOrientationFilterAlpha] = useState(0.01); // Maximum smoothing for orientation
  const [viewMode, setViewMode] = useState<'all' | 'scrollable'>('all');
  const [scrollPosition, setScrollPosition] = useState(0);
  const [windowSize, setWindowSize] = useState(200);
  const [collapsedCharts, setCollapsedCharts] = useState({
    stateTimeline: false,
    virtualVsReal: false,
    gravityForward: false
  });

  // Master Signal Viewer state
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState(0);
  const [filterAlpha, setFilterAlpha] = useState(0.05); // EMA filter strength
  const [observerAlpha, setObserverAlpha] = useState(0.05); // Observer filter strength (heavy smoothing)
  const [signalControls, setSignalControls] = useState<Record<string, { visible: boolean; offset: number; color: string; width?: number; yAxisID?: string; label?: string }>>({
    // Raw signals (faded)
    accelRawX: { visible: false, offset: 0, color: 'rgba(239, 68, 68, 0.3)', width: 1 },
    accelRawY: { visible: false, offset: 0, color: 'rgba(245, 158, 11, 0.3)', width: 1 },
    accelRawZ: { visible: false, offset: 0, color: 'rgba(59, 130, 246, 0.3)', width: 1 },

    // Filtered accel (solid)
    accelFilteredX: { visible: false, offset: 0, color: '#ef4444', width: 2 },
    accelFilteredY: { visible: false, offset: 0, color: '#f59e0b', width: 2 },
    accelFilteredZ: { visible: false, offset: 0, color: '#3b82f6', width: 2 },

    // Gyro raw (faded)
    gyroRawX: { visible: false, offset: 0, color: 'rgba(139, 92, 246, 0.3)', width: 1 },
    gyroRawY: { visible: false, offset: 0, color: 'rgba(236, 72, 153, 0.3)', width: 1 },
    gyroRawZ: { visible: false, offset: 0, color: 'rgba(6, 182, 212, 0.3)', width: 1 },

    // Gyro filtered (solid)
    gyroFilteredX: { visible: false, offset: 0, color: '#8b5cf6', width: 2 },
    gyroFilteredY: { visible: false, offset: 0, color: '#ec4899', width: 2 },
    gyroFilteredZ: { visible: false, offset: 0, color: '#06b6d4', width: 2 },

    // Magnetometer
    magX: { visible: false, offset: 0, color: '#10b981', width: 1 },
    magY: { visible: false, offset: 0, color: '#14b8a6', width: 1 },
    magZ: { visible: false, offset: 0, color: '#22c55e', width: 1 },

    // === LATERAL ACCEL TRIFECTA ===
    accelLinearY_measured: { visible: true, offset: 0, color: '#ef4444', width: 3, label: 'accelLinearY_measured' },
    accelLinearY_fromGyro: { visible: true, offset: 0, color: '#f97316', width: 2, label: 'accelLinearY_fromGyro' },
    accelLinearY_fromMag: { visible: true, offset: 0, color: '#84cc16', width: 2, label: 'accelLinearY_fromMag' },

    // === ROTATION RATE TRIFECTA ===
    gyroZ_measured: { visible: false, offset: 0, color: '#3b82f6', width: 3, label: 'gyroZ_measured' },
    gyroZ_fromAccel: { visible: false, offset: 0, color: '#06b6d4', width: 2, label: 'gyroZ_fromAccel' },
    gyroZ_fromMag: { visible: false, offset: 0, color: '#0891b2', width: 2, label: 'gyroZ_fromMag' },

    // === HEADING TRIFECTA ===
    heading_measured: { visible: false, offset: 0, color: '#8b5cf6', width: 3, label: 'heading_measured' },
    heading_fromAccel: { visible: false, offset: 0, color: '#a855f7', width: 2, label: 'heading_fromAccel' },
    heading_fromGyro: { visible: false, offset: 0, color: '#c084fc', width: 2, label: 'heading_fromGyro' },

    // Transformed (primes) - MAIN SIGNALS (OUTPUT)
    xPrime: { visible: true, offset: 0, color: '#dc2626', width: 3 },
    yPrime: { visible: false, offset: 0, color: '#2563eb', width: 3 },
    zPrime: { visible: false, offset: 0, color: '#16a34a', width: 3 },

    // Virtual accelerations
    virtualForward: { visible: true, offset: 0, color: '#10b981', width: 2 },
    virtualLateral: { visible: false, offset: 0, color: '#f59e0b', width: 2 },

    // GPS Speed (right axis)
    gpsSpeed: { visible: true, offset: 0, color: '#8b5cf6', width: 2, yAxisID: 'y1' },

    // Confidence
    confidence: { visible: false, offset: 0, color: '#ec4899', width: 1, yAxisID: 'y1' }
  });

  // Auth guard
  useEffect(() => {
    if (!loading && !user) {
      router.push('/');
    }
  }, [user, loading, router]);

  // Initialize storage manager
  useEffect(() => {
    StorageManager.initialize(database);
  }, []);

  // Load signal controls from localStorage on mount
  useEffect(() => {
    const savedControls = localStorage.getItem('masterSignalViewerControls');
    if (savedControls) {
      try {
        const parsed = JSON.parse(savedControls);
        setSignalControls(prev => ({
          ...prev,
          ...parsed // Merge saved with defaults
        }));
      } catch (e) {
        console.error('Failed to load saved signal controls:', e);
      }
    }
  }, []);

  // Save signal controls to localStorage when they change
  useEffect(() => {
    localStorage.setItem('masterSignalViewerControls', JSON.stringify(signalControls));
  }, [signalControls]);

  // Load filter settings from localStorage on mount
  useEffect(() => {
    const savedFilterAlpha = localStorage.getItem('masterSignalViewerFilterAlpha');
    const savedWindowSize = localStorage.getItem('masterSignalViewerWindowSize');

    if (savedFilterAlpha) {
      try {
        setFilterAlpha(parseFloat(savedFilterAlpha));
      } catch (e) {
        console.error('Failed to load saved filter alpha:', e);
      }
    }

    if (savedWindowSize) {
      try {
        setWindowSize(parseInt(savedWindowSize));
      } catch (e) {
        console.error('Failed to load saved window size:', e);
      }
    }
  }, []);

  // Save filter settings to localStorage when they change
  useEffect(() => {
    localStorage.setItem('masterSignalViewerFilterAlpha', filterAlpha.toString());
  }, [filterAlpha]);

  useEffect(() => {
    localStorage.setItem('masterSignalViewerWindowSize', windowSize.toString());
  }, [windowSize]);

  // Fetch session detail
  useEffect(() => {
    const fetchSessionDetail = async () => {
      if (!user || !sessionId) return;

      setIsLoading(true);
      setError(null);
      try {
        const sessionDetail = await StorageManager.getSessionDetail(user.uid, sessionId);
        if (!sessionDetail) {
          setError('Session not found');
        } else {
          setSession(sessionDetail);
        }
      } catch (error) {
        console.error('Error fetching session detail:', error);
        setError('Failed to load session data');
      } finally {
        setIsLoading(false);
      }
    };

    if (user && sessionId) {
      fetchSessionDetail();
    }
  }, [user, sessionId]);


  // Apply floating calibration with current parameters
  const calibrationResult = useMemo(() => {
    if (!session) return null;
    return applyFloatingCalibration(
      session.accelerometerData,
      session.gyroscopeData,
      session.gpsData || [],
      alpha,
      observerAlpha
    );
  }, [session, alpha, observerAlpha]);

  // Data slicing logic
  const getSlicedData = (data: Vector3D[]) => {
    if (viewMode === 'all' || data.length <= windowSize) {
      return data;
    }
    return data.slice(scrollPosition, scrollPosition + windowSize);
  };

  const totalDataPoints = session ? session.accelerometerData.length : 0;
  const maxScrollPosition = Math.max(0, totalDataPoints - windowSize);

  const handlePrev = () => {
    setScrollPosition(Math.max(0, scrollPosition - windowSize));
  };

  const handleNext = () => {
    setScrollPosition(Math.min(maxScrollPosition, scrollPosition + windowSize));
  };

  const formatDate = (timestamp: number) => {
    return new Date(timestamp).toLocaleString();
  };

  const formatDuration = (startTime: number, endTime?: number) => {
    if (!endTime) return 'In Progress';
    const durationMs = endTime - startTime;
    const seconds = Math.floor(durationMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  };

  const handleDelete = async () => {
    if (!user || !sessionId) return;

    const confirmed = window.confirm(
      `Delete session ${sessionId}? This cannot be undone.`
    );

    if (!confirmed) return;

    try {
      const success = await StorageManager.deleteSession(user.uid, sessionId);
      if (success) {
        router.push('/sessions');
      } else {
        alert('Failed to delete session');
      }
    } catch (error) {
      console.error('Error deleting session:', error);
      alert('Error deleting session');
    }
  };

  // Create confidence chart data with speed
  const confidenceChartData = useMemo(() => {
    if (!calibrationResult || !session) return null;

    // Convert confidence to Vector3D format and apply slicing
    const confidenceAsVectors = calibrationResult.confidence.map((c, i) => ({
      x: 0,
      y: c * 100, // Convert to percentage
      z: 0,
      timestamp: i
    }));
    const slicedConfidence = getSlicedData(confidenceAsVectors);

    // INTERPOLATE GPS speed to match confidence length
    let slicedSpeed: Vector3D[] = [];
    if (!session.gpsData || session.gpsData.length === 0) {
      console.warn('No GPS data available for this session');
      // Fill with zeros to match confidence length
      slicedSpeed = getSlicedData(confidenceAsVectors.map((c, i) => ({
        x: 0, y: 0, z: 0, timestamp: i
      })));
    } else {
      // Create speed array matching confidence length via interpolation
      const targetLength = calibrationResult.confidence.length;
      const gpsData = session.gpsData;
      const speedVectors: Vector3D[] = [];

      for (let i = 0; i < targetLength; i++) {
        const gpsRatio = (i / targetLength) * gpsData.length;
        const prevIndex = Math.floor(gpsRatio);
        const nextIndex = Math.min(prevIndex + 1, gpsData.length - 1);

        let speed = 0;
        if (prevIndex === nextIndex) {
          speed = gpsData[prevIndex]?.mph || 0;
        } else {
          const ratio = gpsRatio - prevIndex;
          const prevSpeed = gpsData[prevIndex]?.mph || 0;
          const nextSpeed = gpsData[nextIndex]?.mph || 0;
          speed = prevSpeed + (nextSpeed - prevSpeed) * ratio;
        }

        speedVectors.push({ x: 0, y: speed, z: 0, timestamp: i });
      }

      slicedSpeed = getSlicedData(speedVectors);
    }

    // Use actual datapoint indices for labels
    const startIndex = viewMode === 'scrollable' ? scrollPosition : 0;
    const indices = slicedConfidence.map((_, index) => (startIndex + index).toString());

    return {
      labels: indices,
      datasets: [
        {
          label: 'Calibration Confidence (%)',
          data: slicedConfidence.map(p => p.y),
          borderColor: '#10b981',  // Green
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
          yAxisID: 'y'  // Left axis (0-100%)
        },
        {
          label: 'Vehicle Speed (mph)',
          data: slicedSpeed.map(p => p.y),
          borderColor: '#8b5cf6',  // Purple
          backgroundColor: 'transparent',
          borderWidth: 3,  // Thicker line for better visibility
          pointRadius: 0,
          fill: false,
          yAxisID: 'y1'  // Right axis (0-80 mph)
        }
      ]
    };
  }, [calibrationResult, session, viewMode, scrollPosition, windowSize]);

  // Create gravity & forward vectors chart data
  const gravityForwardChartData = useMemo(() => {
    if (!calibrationResult) return null;

    const slicedGravity = getSlicedData(calibrationResult.gravityHistory);
    const slicedForward = getSlicedData(calibrationResult.forwardHistory);

    // Use actual datapoint indices for labels
    const startIndex = viewMode === 'scrollable' ? scrollPosition : 0;
    const indices = slicedGravity.map((_, index) => (startIndex + index).toString());

    return {
      labels: indices,
      datasets: [
        // Gravity vectors
        {
          label: 'Gravity X',
          data: slicedGravity.map(p => p.x),
          borderColor: '#ef4444',
          backgroundColor: 'rgba(239, 68, 68, 0.1)',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
        },
        {
          label: 'Gravity Y',
          data: slicedGravity.map(p => p.y),
          borderColor: '#f59e0b',
          backgroundColor: 'rgba(245, 158, 11, 0.1)',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
        },
        {
          label: 'Gravity Z',
          data: slicedGravity.map(p => p.z),
          borderColor: '#10b981',
          backgroundColor: 'rgba(16, 185, 129, 0.1)',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
        },
        // Forward vectors
        {
          label: 'Forward X',
          data: slicedForward.map(p => p.x),
          borderColor: '#8b5cf6',
          backgroundColor: 'rgba(139, 92, 246, 0.1)',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
          borderDash: [3, 3],
        },
        {
          label: 'Forward Y',
          data: slicedForward.map(p => p.y),
          borderColor: '#ec4899',
          backgroundColor: 'rgba(236, 72, 153, 0.1)',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
          borderDash: [3, 3],
        },
        {
          label: 'Forward Z',
          data: slicedForward.map(p => p.z),
          borderColor: '#06b6d4',
          backgroundColor: 'rgba(6, 182, 212, 0.1)',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
          borderDash: [3, 3],
        }
      ]
    };
  }, [calibrationResult, viewMode, scrollPosition, windowSize]);

  // Create gravity magnitude convergence chart data
  const gravityMagnitudeData = useMemo(() => {
    if (!calibrationResult) return null;

    // Calculate magnitude at each sample
    const magnitudes = calibrationResult.gravityHistory.map((g, i) => ({
      x: 0,
      y: Math.sqrt(g.x**2 + g.y**2 + g.z**2),
      z: 0,
      timestamp: i
    }));

    const slicedMagnitudes = getSlicedData(magnitudes);
    const startIndex = viewMode === 'scrollable' ? scrollPosition : 0;
    const indices = slicedMagnitudes.map((_, index) => (startIndex + index).toString());

    return {
      labels: indices,
      datasets: [
        {
          label: 'Gravity Magnitude (m/sÂ²)',
          data: slicedMagnitudes.map(p => p.y),
          borderColor: '#10b981',
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 0,
          fill: false
        },
        {
          label: 'Target (9.8 m/sÂ²)',
          data: slicedMagnitudes.map(() => 9.8),
          borderColor: '#ef4444',
          borderDash: [5, 5],
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0,
          fill: false
        }
      ]
    };
  }, [calibrationResult, viewMode, scrollPosition, windowSize]);

  // Create combined acceleration analysis chart data
  const accelerationAnalysisData = useMemo(() => {
    if (!calibrationResult || !session) return null;

    // 1. GPS virtual forward acceleration (ground truth)
    const slicedGPSAccel = getSlicedData(calibrationResult.virtualForwardAccel.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));

    // 2. Raw accelerometer X, Y, Z (includes gravity)
    const slicedRawX = getSlicedData(session.accelerometerData.map((a, i) => ({
      x: 0, y: a.x, z: 0, timestamp: i
    })));
    const slicedRawY = getSlicedData(session.accelerometerData.map((a, i) => ({
      x: 0, y: a.y, z: 0, timestamp: i
    })));
    const slicedRawZ = getSlicedData(session.accelerometerData.map((a, i) => ({
      x: 0, y: a.z, z: 0, timestamp: i
    })));

    // 3. Linear acceleration X, Y, Z (gravity removed)
    const linearAccels = session.accelerometerData.map((accel, i) => {
      const grav = calibrationResult.gravityHistory[i] || {x: 0, y: 0, z: 0};
      return {
        x: accel.x - grav.x,
        y: accel.y - grav.y,
        z: accel.z - grav.z,
        timestamp: i
      };
    });

    const slicedLinearX = getSlicedData(linearAccels.map((a, i) => ({
      x: 0, y: a.x, z: 0, timestamp: i
    })));
    const slicedLinearY = getSlicedData(linearAccels.map((a, i) => ({
      x: 0, y: a.y, z: 0, timestamp: i
    })));
    const slicedLinearZ = getSlicedData(linearAccels.map((a, i) => ({
      x: 0, y: a.z, z: 0, timestamp: i
    })));

    // 4. Linear acceleration magnitude
    const linearMags = linearAccels.map((a, i) => ({
      x: 0,
      y: Math.sqrt(a.x**2 + a.y**2 + a.z**2),
      z: 0,
      timestamp: i
    }));
    const slicedLinearMag = getSlicedData(linearMags);

    // === ADD EMA FILTERING ===

    // Filter GPS virtual acceleration
    const gpsAccelArray = calibrationResult.virtualForwardAccel;
    const filteredGPSAccel = exponentialMovingAverage(gpsAccelArray, orientationFilterAlpha);

    // Filter sensor linear magnitude
    const sensorMagArray = linearMags.map(m => m.y);
    const filteredSensorMag = exponentialMovingAverage(sensorMagArray, orientationFilterAlpha);

    // Filter individual linear components
    const linearXArray = linearAccels.map(a => a.x);
    const linearYArray = linearAccels.map(a => a.y);
    const linearZArray = linearAccels.map(a => a.z);

    const filteredLinearX = exponentialMovingAverage(linearXArray, orientationFilterAlpha);
    const filteredLinearY = exponentialMovingAverage(linearYArray, orientationFilterAlpha);
    const filteredLinearZ = exponentialMovingAverage(linearZArray, orientationFilterAlpha);

    // Slice filtered data
    const slicedFilteredGPS = getSlicedData(filteredGPSAccel.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));

    const slicedFilteredSensorMag = getSlicedData(filteredSensorMag.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));

    const slicedFilteredLinearX = getSlicedData(filteredLinearX.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));
    const slicedFilteredLinearY = getSlicedData(filteredLinearY.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));
    const slicedFilteredLinearZ = getSlicedData(filteredLinearZ.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));

    // === ADD TRANSFORMED VEHICLE COORDINATES ===

    // Get the transformed data (already calculated in calibration)
    const transformedData = calibrationResult.transformed;

    // Separate into X', Y', Z' components
    const transformedXArray = transformedData.map(t => t.x);
    const transformedYArray = transformedData.map(t => t.y);
    const transformedZArray = transformedData.map(t => t.z);

    // Apply EMA filtering to transformed data
    const filteredTransformedX = exponentialMovingAverage(transformedXArray, orientationFilterAlpha);
    const filteredTransformedY = exponentialMovingAverage(transformedYArray, orientationFilterAlpha);
    const filteredTransformedZ = exponentialMovingAverage(transformedZArray, orientationFilterAlpha);

    // Slice transformed data
    const slicedTransformedX = getSlicedData(filteredTransformedX.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));
    const slicedTransformedY = getSlicedData(filteredTransformedY.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));
    const slicedTransformedZ = getSlicedData(filteredTransformedZ.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));

    // Also get raw (unfiltered) transformed for comparison
    const slicedRawTransformedX = getSlicedData(transformedXArray.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));
    const slicedRawTransformedY = getSlicedData(transformedYArray.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));
    const slicedRawTransformedZ = getSlicedData(transformedZArray.map((v, i) => ({
      x: 0, y: v, z: 0, timestamp: i
    })));

    const startIndex = viewMode === 'scrollable' ? scrollPosition : 0;
    const indices = slicedGPSAccel.map((_, index) => (startIndex + index).toString());

    return {
      labels: indices,
      datasets: [
        // === GPS GROUND TRUTH ===
        {
          label: 'ðŸŸ¢ GPS Accel [FILTERED]',
          data: slicedFilteredGPS.map(p => p.y),
          borderColor: '#059669',
          backgroundColor: 'transparent',
          borderWidth: 4,
          pointRadius: 0
        },

        // === TRANSFORMED VEHICLE COORDINATES (FILTERED - THICK) ===
        {
          label: "x' Forward/Back [FILTERED]",
          data: slicedTransformedX.map(p => p.y),
          borderColor: '#dc2626',  // Red
          backgroundColor: 'transparent',
          borderWidth: 3,
          pointRadius: 0
        },
        {
          label: "y' Lateral (turn) [FILTERED]",
          data: slicedTransformedY.map(p => p.y),
          borderColor: '#2563eb',  // Blue
          backgroundColor: 'transparent',
          borderWidth: 3,
          pointRadius: 0
        },
        {
          label: "z' Vertical (bump) [FILTERED]",
          data: slicedTransformedZ.map(p => p.y),
          borderColor: '#16a34a',  // Green
          backgroundColor: 'transparent',
          borderWidth: 3,
          pointRadius: 0
        },

        // === TRANSFORMED RAW (THIN) ===
        {
          label: "x' Forward/Back [raw]",
          data: slicedRawTransformedX.map(p => p.y),
          borderColor: 'rgba(220, 38, 38, 0.3)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },
        {
          label: "y' Lateral [raw]",
          data: slicedRawTransformedY.map(p => p.y),
          borderColor: 'rgba(37, 99, 235, 0.3)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },
        {
          label: "z' Vertical [raw]",
          data: slicedRawTransformedZ.map(p => p.y),
          borderColor: 'rgba(22, 163, 74, 0.3)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },

        // === KEEP FILTERED SENSOR MAGNITUDE FOR COMPARISON ===
        {
          label: 'ðŸ”´ Sensor Mag (phone) [FILTERED]',
          data: slicedFilteredSensorMag.map(p => p.y),
          borderColor: '#f59e0b',  // Orange
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 0,
          borderDash: [5, 5]
        },

        // Keep other phone-coordinate lines very faded (for reference only)
        {
          label: 'Linear X (phone) [FILTERED]',
          data: slicedFilteredLinearX.map(p => p.y),
          borderColor: 'rgba(153, 27, 27, 0.2)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0,
          borderDash: [3, 3]
        },
        {
          label: 'Linear Y (phone) [FILTERED]',
          data: slicedFilteredLinearY.map(p => p.y),
          borderColor: 'rgba(146, 64, 14, 0.2)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0,
          borderDash: [3, 3]
        },
        {
          label: 'Linear Z (phone) [FILTERED]',
          data: slicedFilteredLinearZ.map(p => p.y),
          borderColor: 'rgba(30, 58, 138, 0.2)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0,
          borderDash: [3, 3]
        },

        // Raw phone coordinates - very faded
        {
          label: 'GPS Accel [raw]',
          data: slicedGPSAccel.map(p => p.y),
          borderColor: 'rgba(16, 185, 129, 0.15)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },
        {
          label: 'Sensor Mag [raw]',
          data: slicedLinearMag.map(p => p.y),
          borderColor: 'rgba(245, 158, 11, 0.15)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },
        {
          label: 'Linear X [raw]',
          data: slicedLinearX.map(p => p.y),
          borderColor: 'rgba(239, 68, 68, 0.1)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },
        {
          label: 'Linear Y [raw]',
          data: slicedLinearY.map(p => p.y),
          borderColor: 'rgba(245, 158, 11, 0.1)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },
        {
          label: 'Linear Z [raw]',
          data: slicedLinearZ.map(p => p.y),
          borderColor: 'rgba(59, 130, 246, 0.1)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },
        {
          label: 'Raw X (with gravity)',
          data: slicedRawX.map(p => p.y),
          borderColor: 'rgba(239, 68, 68, 0.08)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },
        {
          label: 'Raw Y (with gravity)',
          data: slicedRawY.map(p => p.y),
          borderColor: 'rgba(245, 158, 11, 0.08)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        },
        {
          label: 'Raw Z (with gravity)',
          data: slicedRawZ.map(p => p.y),
          borderColor: 'rgba(59, 130, 246, 0.08)',
          backgroundColor: 'transparent',
          borderWidth: 1,
          pointRadius: 0
        }
      ]
    };
  }, [calibrationResult, session, viewMode, scrollPosition, windowSize, orientationFilterAlpha]);

  // Apply exponential moving average filter
  function applyEMAFilter(data: number[], alpha: number): number[] {
    if (data.length === 0) return [];
    const result: number[] = [];
    let smoothed = data[0];

    for (let i = 0; i < data.length; i++) {
      const val = data[i];
      if (isNaN(val) || !isFinite(val)) {
        result.push(smoothed); // Use previous valid value
        continue;
      }
      smoothed = alpha * val + (1 - alpha) * smoothed;
      result.push(smoothed);
    }
    return result;
  }

  // Helper function to unwrap angles (remove 360Â° jumps)
  function unwrapAngles(angles: number[]): number[] {
    if (angles.length === 0) return [];

    const unwrapped: number[] = [angles[0]];
    let offset = 0;

    for (let i = 1; i < angles.length; i++) {
      let diff = angles[i] - angles[i - 1];

      // Detect wraparound
      if (diff > 180) {
        offset -= 360;
      } else if (diff < -180) {
        offset += 360;
      }

      unwrapped.push(angles[i] + offset);
    }

    return unwrapped;
  }

  // Master Signal Viewer - Automotive-style comprehensive signal display with filtered signals
  const masterSignalViewerData = useMemo(() => {
    if (!calibrationResult || !session) return null;

    // Extract raw signals
    const rawAccelX = session.accelerometerData.map(a => a.x);
    const rawAccelY = session.accelerometerData.map(a => a.y);
    const rawAccelZ = session.accelerometerData.map(a => a.z);

    const rawGyroX = session.gyroscopeData.map(g => g.x);
    const rawGyroY = session.gyroscopeData.map(g => g.y);
    const rawGyroZ = session.gyroscopeData.map(g => g.z);

    // Magnetometer debug logging
    console.log('Magnetometer debug:', {
      hasMagData: !!session.magnetometerData,
      magLength: session.magnetometerData?.length || 0,
      firstMag: session.magnetometerData?.[0],
      lastMag: session.magnetometerData?.[session.magnetometerData.length - 1],
      sample: session.magnetometerData?.slice(0, 5)
    });

    const rawMagX = session.magnetometerData?.map(m => {
      let val = m.x;
      if (isNaN(val) || !isFinite(val)) return 0;

      // If values are huge (>100), might be in microtesla, scale down
      if (Math.abs(val) > 100) {
        val = val / 1000; // Convert ÂµT to mT or similar
      }

      return val;
    }) || [];
    const rawMagY = session.magnetometerData?.map(m => {
      let val = m.y;
      if (isNaN(val) || !isFinite(val)) return 0;
      if (Math.abs(val) > 100) val = val / 1000;
      return val;
    }) || [];
    const rawMagZ = session.magnetometerData?.map(m => {
      let val = m.z;
      if (isNaN(val) || !isFinite(val)) return 0;
      if (Math.abs(val) > 100) val = val / 1000;
      return val;
    }) || [];

    // Apply unwrapping to remove 360Â° jumps
    const unwrappedMagX = unwrapAngles(rawMagX);
    const unwrappedMagY = unwrapAngles(rawMagY);
    const unwrappedMagZ = unwrapAngles(rawMagZ);

    // Scale magnetometer for display (360Â° becomes 36 on graph)
    const displayMagX = unwrappedMagX.map(v => v / 10);
    const displayMagY = unwrappedMagY.map(v => v / 10);
    const displayMagZ = unwrappedMagZ.map(v => v / 10);

    console.log('Magnetometer after processing:', {
      rawMagXRange: [Math.min(...rawMagX), Math.max(...rawMagX)],
      unwrappedMagXRange: [Math.min(...unwrappedMagX), Math.max(...unwrappedMagX)],
      scaledRange: [Math.min(...displayMagX), Math.max(...displayMagX)],
      note: 'Divided by 10 for display (360Â° â†’ 36)',
      sampleUnwrapped: unwrappedMagX.slice(0, 10)
    });

    // Apply filtering using state variable filterAlpha
    const filteredAccelX = applyEMAFilter(rawAccelX, filterAlpha);
    const filteredAccelY = applyEMAFilter(rawAccelY, filterAlpha);
    const filteredAccelZ = applyEMAFilter(rawAccelZ, filterAlpha);

    const filteredGyroX = applyEMAFilter(rawGyroX, filterAlpha);
    const filteredGyroY = applyEMAFilter(rawGyroY, filterAlpha);
    const filteredGyroZ = applyEMAFilter(rawGyroZ, filterAlpha);

    // Slice data based on scroll position
    const sliceData = (arr: number[]) => {
      if (viewMode === 'all' || arr.length <= windowSize) return arr;
      return arr.slice(scrollPosition, scrollPosition + windowSize);
    };

    // Create datasets with visibility and offset controls
    const datasets: any[] = [];

    // Helper to add dataset
    const addDataset = (key: string, data: number[], control: any) => {
  console.log(`addDataset called: ${key}`, { hasControl: !!control, visible: control?.visible, dataLength: data?.length, willAdd: !!(control && control.visible && data && data.length > 0) });
      if (!control || !control.visible) return;

      const slicedData = sliceData(data);
  console.log(`  ${key} after slice:`, slicedData.length);
      if (slicedData.length === 0) return;

  console.log(`  âœ… ${key} ADDED to chart`);
      datasets.push({
        label: control.label || key,  // Use custom label if available, otherwise use key
        data: slicedData.map(v => v + control.offset),
        borderColor: control.color,
        backgroundColor: 'transparent',
        borderWidth: control.width || 1,
        pointRadius: 0,
        yAxisID: control.yAxisID || 'y'
      });
    };

    // Add all signals
    addDataset('accelRawX', rawAccelX, signalControls.accelRawX);
    addDataset('accelRawY', rawAccelY, signalControls.accelRawY);
    addDataset('accelRawZ', rawAccelZ, signalControls.accelRawZ);

    addDataset('accelFilteredX', filteredAccelX, signalControls.accelFilteredX);
    addDataset('accelFilteredY', filteredAccelY, signalControls.accelFilteredY);
    addDataset('accelFilteredZ', filteredAccelZ, signalControls.accelFilteredZ);

    addDataset('gyroRawX', rawGyroX, signalControls.gyroRawX);
    addDataset('gyroRawY', rawGyroY, signalControls.gyroRawY);
    addDataset('gyroRawZ', rawGyroZ, signalControls.gyroRawZ);

    addDataset('gyroFilteredX', filteredGyroX, signalControls.gyroFilteredX);
    addDataset('gyroFilteredY', filteredGyroY, signalControls.gyroFilteredY);
    addDataset('gyroFilteredZ', filteredGyroZ, signalControls.gyroFilteredZ);

    if (displayMagX.length > 0) {
      addDataset('magX', displayMagX, signalControls.magX);
      addDataset('magY', displayMagY, signalControls.magY);
      addDataset('magZ', displayMagZ, signalControls.magZ);
    }

    // Add transformed (primes) - pre-calculated from calibration, NOT affected by filter slider
    const xPrimeData = calibrationResult.transformed.map(t => t.x);
    const yPrimeData = calibrationResult.transformed.map(t => t.y);
    const zPrimeData = calibrationResult.transformed.map(t => t.z);

    console.log('xPrime data check:', {
      length: xPrimeData.length,
      min: Math.min(...xPrimeData),
      max: Math.max(...xPrimeData),
      avg: xPrimeData.reduce((a, b) => a + b, 0) / xPrimeData.length,
      sample: xPrimeData.slice(0, 10)
    });

    addDataset('xPrime', xPrimeData, signalControls.xPrime);
    addDataset('yPrime', yPrimeData, signalControls.yPrime);
    addDataset('zPrime', zPrimeData, signalControls.zPrime);

    // Add virtual accelerations
    addDataset('virtualForward', calibrationResult.virtualForwardAccel, signalControls.virtualForward);
    addDataset('virtualLateral', calibrationResult.virtualLateralAccel, signalControls.virtualLateral);

    // === CROSS-VERIFICATION TRIFECTA DEBUG ===
    console.log('=== TRIFECTA DEBUG ===');
    console.log('Lateral Accel Trifecta:', {
      measured: {
        min: Math.min(...calibrationResult.accelLinearY_observed),
        max: Math.max(...calibrationResult.accelLinearY_observed),
        avg: calibrationResult.accelLinearY_observed.reduce((a, b) => a + b, 0) / calibrationResult.accelLinearY_observed.length
      },
      fromGyro: {
        min: Math.min(...calibrationResult.observerAccelLinearY_fromGyro),
        max: Math.max(...calibrationResult.observerAccelLinearY_fromGyro),
        avg: calibrationResult.observerAccelLinearY_fromGyro.reduce((a, b) => a + b, 0) / calibrationResult.observerAccelLinearY_fromGyro.length
      },
      fromMag: {
        min: Math.min(...calibrationResult.observerAccelLinearY_fromMag),
        max: Math.max(...calibrationResult.observerAccelLinearY_fromMag),
        avg: calibrationResult.observerAccelLinearY_fromMag.reduce((a, b) => a + b, 0) / calibrationResult.observerAccelLinearY_fromMag.length
      }
    });

    console.log('Rotation Rate Trifecta:', {
      measured: {
        min: Math.min(...calibrationResult.gyroFilteredZ_observed),
        max: Math.max(...calibrationResult.gyroFilteredZ_observed),
        avg: calibrationResult.gyroFilteredZ_observed.reduce((a, b) => a + b, 0) / calibrationResult.gyroFilteredZ_observed.length
      },
      fromAccel: {
        min: Math.min(...calibrationResult.observerGyroZ_fromAccel),
        max: Math.max(...calibrationResult.observerGyroZ_fromAccel),
        avg: calibrationResult.observerGyroZ_fromAccel.reduce((a, b) => a + b, 0) / calibrationResult.observerGyroZ_fromAccel.length
      },
      fromMag: {
        min: Math.min(...calibrationResult.observerGyroZ_fromMag),
        max: Math.max(...calibrationResult.observerGyroZ_fromMag),
        avg: calibrationResult.observerGyroZ_fromMag.reduce((a, b) => a + b, 0) / calibrationResult.observerGyroZ_fromMag.length
      }
    });

    console.log('Heading Trifecta:', {
      measured: {
        min: Math.min(...calibrationResult.heading_observed),
        max: Math.max(...calibrationResult.heading_observed),
        avg: calibrationResult.heading_observed.reduce((a, b) => a + b, 0) / calibrationResult.heading_observed.length
      },
      fromAccel: {
        min: Math.min(...calibrationResult.observerHeading_fromAccel),
        max: Math.max(...calibrationResult.observerHeading_fromAccel),
        avg: calibrationResult.observerHeading_fromAccel.reduce((a, b) => a + b, 0) / calibrationResult.observerHeading_fromAccel.length
      },
      fromGyro: {
        min: Math.min(...calibrationResult.observerHeading_fromGyro),
        max: Math.max(...calibrationResult.observerHeading_fromGyro),
        avg: calibrationResult.observerHeading_fromGyro.reduce((a, b) => a + b, 0) / calibrationResult.observerHeading_fromGyro.length
      }
    });

    // === ADD OBSERVER DATASETS TO CHART ===
    console.log('=== ADDING OBSERVER DATASETS TO CHART ===');
    console.log('Adding observer datasets:', {
      hasAccelYData: !!calibrationResult.accelLinearY_observed,
      accelYLength: calibrationResult.accelLinearY_observed?.length || 0,
      hasGyroZData: !!calibrationResult.gyroFilteredZ_observed,
      gyroZLength: calibrationResult.gyroFilteredZ_observed?.length || 0,
      hasHeadingData: !!calibrationResult.heading_observed,
      headingLength: calibrationResult.heading_observed?.length || 0,
      signalControlsExist: {
        accelLinearY_measured: !!signalControls.accelLinearY_measured,
        accelLinearY_fromGyro: !!signalControls.accelLinearY_fromGyro,
        accelLinearY_fromMag: !!signalControls.accelLinearY_fromMag,
        gyroZ_measured: !!signalControls.gyroZ_measured,
        gyroZ_fromAccel: !!signalControls.gyroZ_fromAccel,
        gyroZ_fromMag: !!signalControls.gyroZ_fromMag,
        heading_measured: !!signalControls.heading_measured,
        heading_fromAccel: !!signalControls.heading_fromAccel,
        heading_fromGyro: !!signalControls.heading_fromGyro
      }
    });

    // Add trifecta datasets with conditional checks
    if (calibrationResult.accelLinearY_observed) {
      addDataset('accelLinearY_measured', calibrationResult.accelLinearY_observed, signalControls.accelLinearY_measured);
      addDataset('accelLinearY_fromGyro', calibrationResult.observerAccelLinearY_fromGyro, signalControls.accelLinearY_fromGyro);
      addDataset('accelLinearY_fromMag', calibrationResult.observerAccelLinearY_fromMag, signalControls.accelLinearY_fromMag);
    }

    if (calibrationResult.gyroFilteredZ_observed) {
      addDataset('gyroZ_measured', calibrationResult.gyroFilteredZ_observed, signalControls.gyroZ_measured);
      addDataset('gyroZ_fromAccel', calibrationResult.observerGyroZ_fromAccel, signalControls.gyroZ_fromAccel);
      addDataset('gyroZ_fromMag', calibrationResult.observerGyroZ_fromMag, signalControls.gyroZ_fromMag);
    }

    if (calibrationResult.heading_observed) {
      addDataset('heading_measured', calibrationResult.heading_observed, signalControls.heading_measured);
      addDataset('heading_fromAccel', calibrationResult.observerHeading_fromAccel, signalControls.heading_fromAccel);
      addDataset('heading_fromGyro', calibrationResult.observerHeading_fromGyro, signalControls.heading_fromGyro);
    }

    // Add GPS speed (right axis) - interpolate to match accelerometer length FIRST
    let interpolatedGPSSpeed: number[] = [];

    console.log('GPS interpolation debug:', {
      hasGPSData: !!session.gpsData,
      gpsLength: session.gpsData?.length || 0,
      accelLength: session.accelerometerData.length,
      firstGPS: session.gpsData?.[0],
      lastGPS: session.gpsData?.[session.gpsData.length - 1]
    });

    if (session.gpsData && session.gpsData.length > 0) {
      const targetLength = session.accelerometerData.length;

      for (let i = 0; i < targetLength; i++) {
        const gpsRatio = (i / targetLength) * session.gpsData.length;
        const prevIndex = Math.floor(gpsRatio);
        const nextIndex = Math.min(prevIndex + 1, session.gpsData.length - 1);

        let speed = 0;
        if (prevIndex === nextIndex) {
          speed = session.gpsData[prevIndex]?.mph || 0;
        } else {
          const ratio = gpsRatio - prevIndex;
          const prevSpeed = session.gpsData[prevIndex]?.mph || 0;
          const nextSpeed = session.gpsData[nextIndex]?.mph || 0;
          speed = prevSpeed + (nextSpeed - prevSpeed) * ratio;
        }

        interpolatedGPSSpeed.push(speed);
      }

      console.log('GPS speed interpolation result:', {
        outputLength: interpolatedGPSSpeed.length,
        min: Math.min(...interpolatedGPSSpeed),
        max: Math.max(...interpolatedGPSSpeed),
        avg: interpolatedGPSSpeed.reduce((a, b) => a + b, 0) / interpolatedGPSSpeed.length,
        sample: interpolatedGPSSpeed.slice(0, 10)
      });
    } else {
      interpolatedGPSSpeed = Array(session.accelerometerData.length).fill(0);
    }

    // NOW slice it like all other signals
    addDataset('gpsSpeed', interpolatedGPSSpeed, signalControls.gpsSpeed);

    // Add confidence
    const confidencePercent = calibrationResult.confidence.map(c => c * 100);
    addDataset('confidence', confidencePercent, signalControls.confidence);

    // Create labels
    const startIndex = viewMode === 'scrollable' ? scrollPosition : 0;
    const dataLength = viewMode === 'all' ? session.accelerometerData.length : Math.min(windowSize, session.accelerometerData.length - scrollPosition);
    const labels = Array.from({length: dataLength}, (_, i) => (startIndex + i).toString());

    return { labels, datasets };
  }, [calibrationResult, session, viewMode, scrollPosition, windowSize, signalControls, filterAlpha]);

  // Mouse handlers for drag scrolling
  const handleMouseDown = (e: React.MouseEvent) => {
    setIsDragging(true);
    setDragStart(e.clientX);
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isDragging || !calibrationResult) return;
    const delta = Math.floor((dragStart - e.clientX) * 2); // pixels to data points
    const maxScroll = calibrationResult.transformed.length - windowSize;
    setScrollPosition(Math.max(0, Math.min(maxScroll, scrollPosition + delta)));
    setDragStart(e.clientX);
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  const handleWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    if (e.deltaY < 0) {
      // Zoom in
      setWindowSize(Math.max(100, windowSize - 50));
    } else {
      // Zoom out
      setWindowSize(Math.min(2000, windowSize + 50));
    }
  };

  const toggleSignal = (key: string) => {
    setSignalControls({
      ...signalControls,
      [key]: { ...signalControls[key], visible: !signalControls[key].visible }
    });
  };

  const updateOffset = (key: string, offset: number) => {
    setSignalControls(prev => ({
      ...prev,
      [key]: { ...prev[key], offset }
    }));
  };

  // Create reference frame visualization chart data
  const referenceFrameChartData = useMemo(() => {
    if (!calibrationResult) return null;

    const slicedData = getSlicedData(calibrationResult.transformed);
    console.log('Vehicle Reference Frame - data points:', slicedData.length);

    // Use actual datapoint indices for labels
    const startIndex = viewMode === 'scrollable' ? scrollPosition : 0;
    const indices = slicedData.map((_, index) => (startIndex + index).toString());

    const xPrimeValues = slicedData.map(point => point.x);
    const yPrimeValues = slicedData.map(point => point.y);
    const zPrimeValues = slicedData.map(point => point.z);
    const zeroLine = slicedData.map(() => 0);

    return {
      labels: indices,
      datasets: [
        // Zero reference line (single dashed gray line at y=0)
        {
          label: 'Zero Reference',
          data: zeroLine,
          borderColor: '#9ca3af',
          backgroundColor: 'transparent',
          borderWidth: 2,
          borderDash: [8, 4],
          pointRadius: 0,
          fill: false,
        },
        // Transformed data (colored solid lines)
        {
          label: 'x\' (forward/back)',
          data: xPrimeValues,
          borderColor: '#ef4444',
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
        },
        {
          label: 'y\' (lateral)',
          data: yPrimeValues,
          borderColor: '#3b82f6',
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
        },
        {
          label: 'z\' (vertical)',
          data: zPrimeValues,
          borderColor: '#10b981',
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
        }
      ]
    };
  }, [calibrationResult, viewMode, scrollPosition, windowSize]);

  // Create state timeline chart data
  const stateTimelineData = useMemo(() => {
    if (!calibrationResult) return null;

    // Apply slicing and add vertical offsets
    const slicedGPSAccel = getSlicedData(calibrationResult.gpsAccelDetected.map((v, i) => ({
      x: 0,
      y: v ? 1.0 : 0.0,  // Bottom line: GPS Accel Detected
      z: 0,
      timestamp: i
    })));

    const slicedTurning = getSlicedData(calibrationResult.turningDetected.map((v, i) => ({
      x: 0,
      y: v ? 1.4 : 0.4,  // Middle line: Turning Detected
      z: 0,
      timestamp: i
    })));

    // Forward update happens when GPS accel detected
    const forwardUpdates = calibrationResult.gpsAccelDetected.map((v, i) =>
      v ? 1.8 : 0.8  // Top line: Forward Update
    );
    const slicedForwardUpdates = getSlicedData(forwardUpdates.map((v, i) => ({ x: 0, y: v, z: 0, timestamp: i })));

    // Use actual datapoint indices for labels
    const startIndex = viewMode === 'scrollable' ? scrollPosition : 0;
    const indices = slicedGPSAccel.map((_, index) => (startIndex + index).toString());

    return {
      labels: indices,
      datasets: [
        {
          label: 'GPS Accel Detected',
          data: slicedGPSAccel.map(p => p.y),
          borderColor: '#10b981',  // Green
          backgroundColor: 'transparent',
          stepped: true,
          borderWidth: 2,
          pointRadius: 0,
          fill: false
        },
        {
          label: 'Turning Detected',
          data: slicedTurning.map(p => p.y),
          borderColor: '#3b82f6',  // Blue
          backgroundColor: 'transparent',
          stepped: true,
          borderWidth: 2,
          pointRadius: 0,
          fill: false
        },
        {
          label: 'Forward Update',
          data: slicedForwardUpdates.map(p => p.y),
          borderColor: '#f59e0b',  // Orange
          backgroundColor: 'transparent',
          stepped: true,
          borderWidth: 2,
          pointRadius: 0,
          fill: false
        }
      ]
    };
  }, [calibrationResult, viewMode, scrollPosition, windowSize]);

  // Create virtual vs real acceleration comparison chart
  const virtualVsRealData = useMemo(() => {
    if (!calibrationResult || !session) return null;

    // Get real accelerometer linear acceleration (remove gravity)
    const slicedRealAccel = getSlicedData(session.accelerometerData.map((accel, i) => {
      const grav = calibrationResult.gravityHistory[i] || { x: 0, y: 0, z: 0 };
      // Project onto forward direction for comparison
      const forward = calibrationResult.forwardHistory[i] || { x: 1, y: 0, z: 0 };
      const forwardMag = Math.sqrt(forward.x ** 2 + forward.y ** 2 + forward.z ** 2);
      if (forwardMag < 0.1) return { x: 0, y: 0, z: 0, timestamp: i };

      const linearAccel = {
        x: accel.x - grav.x,
        y: accel.y - grav.y,
        z: accel.z - grav.z
      };

      // Project onto forward direction
      const forwardAccel = (linearAccel.x * forward.x + linearAccel.y * forward.y + linearAccel.z * forward.z) / forwardMag;

      return { x: 0, y: forwardAccel, z: 0, timestamp: i };
    }));

    const slicedVirtualForward = getSlicedData(calibrationResult.virtualForwardAccel.map((v, i) => ({
      x: 0,
      y: v,
      z: 0,
      timestamp: i
    })));

    // Use actual datapoint indices for labels
    const startIndex = viewMode === 'scrollable' ? scrollPosition : 0;
    const indices = slicedVirtualForward.map((_, index) => (startIndex + index).toString());

    return {
      labels: indices,
      datasets: [
        {
          label: 'GPS Virtual Forward Accel (m/sÂ²)',
          data: slicedVirtualForward.map(p => p.y),
          borderColor: '#10b981',  // Green
          backgroundColor: 'rgba(16, 185, 129, 0.1)',
          borderWidth: 2,
          pointRadius: 0,
          fill: false
        },
        {
          label: 'Real Sensor Forward Accel (m/sÂ²)',
          data: slicedRealAccel.map(p => p.y),
          borderColor: '#ef4444',  // Red
          backgroundColor: 'rgba(239, 68, 68, 0.1)',
          borderWidth: 2,
          pointRadius: 0,
          fill: false
        }
      ]
    };
  }, [calibrationResult, session, viewMode, scrollPosition, windowSize]);

  const avgConfidence = calibrationResult
    ? calibrationResult.confidence.reduce((a, b) => a + b, 0) / calibrationResult.confidence.length
    : 0;

  if (loading || !user) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-xl">Loading...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
        <div className="max-w-7xl mx-auto">
          <div className="bg-white rounded-lg shadow-lg p-6">
            <div className="text-red-600 text-center">
              <h2 className="text-2xl font-bold mb-4">Error</h2>
              <p>{error}</p>
              <button
                onClick={() => router.push('/sessions')}
                className="mt-4 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
              >
                Back to Sessions
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="bg-white rounded-lg shadow-lg p-2 mb-2">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-2xl font-bold text-gray-800">ðŸ“ Floating Calibration Analysis</h1>
              <p className="text-xs text-gray-600">Adaptive vehicle coordinate transformation</p>
            </div>
            <div className="flex gap-3">
              <button
                onClick={() => router.push(`/sessions/${sessionId}`)}
                className="px-3 py-1.5 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700"
              >
                Back to Session
              </button>
              {isAdmin && (
                <button
                  onClick={handleDelete}
                  className="px-3 py-1.5 bg-red-600 text-white text-sm rounded-lg hover:bg-red-700"
                >
                  ðŸ—‘ï¸ Delete
                </button>
              )}
            </div>
          </div>
        </div>

        {isLoading ? (
          <div className="bg-white rounded-lg shadow-lg p-6">
            <div className="text-center py-8">
              <div className="text-gray-600">Loading session data...</div>
            </div>
          </div>
        ) : session && calibrationResult ? (
          <>
            {/* Debug Diagnostic Panel */}
            <div className="bg-yellow-50 border-2 border-yellow-400 rounded-lg p-4 mb-4">
              <h3 className="font-bold text-lg mb-2">ðŸ” Debug Info</h3>
              <div className="grid grid-cols-4 gap-4 text-sm">
                <div>
                  <strong>Scroll Position:</strong> {scrollPosition}<br/>
                  <strong>Window Size:</strong> {windowSize}<br/>
                  <strong>View Mode:</strong> {viewMode}
                </div>
                <div>
                  <strong>Total Data Points:</strong> {session.accelerometerData.length}<br/>
                  <strong>GPS Data Points (orig):</strong> {session.gpsData?.length || 0}<br/>
                  <strong>GPS with speed &gt; 0:</strong> {session.gpsData?.filter(g => g.mps > 0).length || 0}<br/>
                  <strong>GPS Sample Rate:</strong> {session.gpsData?.length ? ((session.gpsData.length / session.accelerometerData.length) * 60).toFixed(1) : 0} Hz<br/>
                  <strong>GPS Coverage:</strong> {session.gpsData?.length ? ((session.gpsData.length / session.accelerometerData.length) * 100).toFixed(1) : 0}%<br/>
                  <strong>GPS Interpolated:</strong> {session.gpsData?.length !== session.accelerometerData.length ? 'Yes' : 'No'}
                </div>
                <div>
                  <strong>Forward Updates:</strong> {calibrationResult.forwardUpdateCount[calibrationResult.forwardUpdateCount.length - 1]}<br/>
                  <strong>Forward Magnitude:</strong> {(() => {
                    const last = calibrationResult.forwardHistory[calibrationResult.forwardHistory.length - 1];
                    return Math.sqrt(last.x ** 2 + last.y ** 2 + last.z ** 2).toFixed(3);
                  })()}<br/>
                  <strong>Sample GPS Speed:</strong> {session.gpsData?.[100]?.mph.toFixed(1) || 'N/A'} mph
                </div>
                <div>
                  <strong>Gravity Vector (final):</strong><br/>
                  &nbsp;&nbsp;X: {calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1].x.toFixed(3)} m/sÂ²<br/>
                  &nbsp;&nbsp;Y: {calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1].y.toFixed(3)} m/sÂ²<br/>
                  &nbsp;&nbsp;Z: {calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1].z.toFixed(3)} m/sÂ²<br/>
                  <strong>Gravity Magnitude:</strong> {Math.sqrt(
                    calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1].x ** 2 +
                    calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1].y ** 2 +
                    calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1].z ** 2
                  ).toFixed(3)} m/sÂ² (target: 9.800)<br/>
                  <strong>Gravity Error:</strong> {(
                    (Math.sqrt(
                      calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1].x ** 2 +
                      calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1].y ** 2 +
                      calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1].z ** 2
                    ) - 9.8) / 9.8 * 100
                  ).toFixed(1)}%<br/>
                  <strong>Actual Sample Rate:</strong> {calibrationResult.actualSampleRate?.toFixed(1) || '60.0'} Hz<br/>
                  <strong>Assumed Rate:</strong> 60.0 Hz
                  {calibrationResult.actualSampleRate && Math.abs(calibrationResult.actualSampleRate - 60) > 5 && (
                    <>
                      <br/>
                      <span className="text-orange-600 font-semibold text-xs">
                        âš ï¸ Rate mismatch detected!
                      </span>
                    </>
                  )}
                </div>
                <div>
                  <strong>Data Point Counts:</strong><br/>
                  &nbsp;&nbsp;Session Accel Data: {session.accelerometerData.length}<br/>
                  &nbsp;&nbsp;Session GPS Data: {session.gpsData?.length || 0}<br/>
                  &nbsp;&nbsp;Calibration Transformed: {calibrationResult.transformed.length}<br/>
                  &nbsp;&nbsp;Calibration Gravity History: {calibrationResult.gravityHistory.length}<br/>
                  &nbsp;&nbsp;Calibration Forward History: {calibrationResult.forwardHistory.length}<br/>
                  {calibrationResult.transformed.length !== session.accelerometerData.length && (
                    <span className="text-red-600 font-semibold text-xs">
                      <br/>âŒ LENGTH MISMATCH! Transformed ({calibrationResult.transformed.length})
                      â‰  Accel ({session.accelerometerData.length})
                    </span>
                  )}
                </div>
              </div>
            </div>

            {/* Session Metadata */}
            <div className="bg-white rounded-lg shadow-lg p-2 mb-2">
              <h2 className="text-xl font-bold mb-3 text-gray-800">Session Information</h2>
              <div className="grid md:grid-cols-4 gap-3">
                <div>
                  <div className="text-xs text-gray-600">Session ID</div>
                  <div className="font-semibold text-sm text-gray-800">{session.sessionId}</div>
                </div>
                <div>
                  <div className="text-xs text-gray-600">Start Time</div>
                  <div className="font-semibold text-sm text-gray-800">{formatDate(session.startTime)}</div>
                </div>
                <div>
                  <div className="text-xs text-gray-600">Duration</div>
                  <div className="font-semibold text-sm text-gray-800">
                    {formatDuration(session.startTime, session.endTime)}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-gray-600">Data Points</div>
                  <div className="font-semibold text-sm text-gray-800">
                    {session.accelerometerData.length.toLocaleString()}
                  </div>
                </div>
              </div>
            </div>

            {/* Calibration Parameters */}
            <div className="bg-white rounded-lg shadow-lg p-2 mb-2">
              <h2 className="text-xl font-bold mb-3 text-gray-800">Calibration Parameters</h2>

              <div className="space-y-3">
                {/* Smoothing Parameter */}
                <div>
                  <div className="flex items-center justify-between mb-1">
                    <label className="text-sm font-semibold text-gray-700">
                      Smoothing (Î±): <span className="text-blue-600">{alpha.toFixed(2)}</span>
                    </label>
                    <span className="text-xs text-gray-500">0.90-0.99</span>
                  </div>
                  <input
                    type="range"
                    min="0.90"
                    max="0.99"
                    step="0.01"
                    value={alpha}
                    onChange={(e) => setAlpha(parseFloat(e.target.value))}
                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                  />
                </div>

                {/* Orientation Filter Alpha (EMA) */}
                <div className="mb-3">
                  <div className="flex justify-between items-center mb-1">
                    <label className="text-sm font-medium">
                      Orientation Filter Strength (Î±):
                    </label>
                    <span className="text-sm font-semibold text-blue-600">
                      {orientationFilterAlpha.toFixed(3)} ({orientationFilterAlpha < 0.1 ? 'Heavy' : orientationFilterAlpha < 0.3 ? 'Moderate' : 'Light'} smoothing)
                    </span>
                  </div>
                  <input
                    type="range"
                    min="0.01"
                    max="0.95"
                    step="0.01"
                    value={orientationFilterAlpha}
                    onChange={(e) => setOrientationFilterAlpha(parseFloat(e.target.value))}
                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                  />
                  <div className="flex justify-between text-xs text-gray-500 mt-1">
                    <span>0.01 (max smooth)</span>
                    <span>0.05 (heavy)</span>
                    <span>0.20 (moderate)</span>
                    <span>0.50 (light)</span>
                    <span>0.95 (minimal)</span>
                  </div>
                  <p className="text-xs text-gray-600 mt-1">
                    Exponential Moving Average (EMA) for GPS/sensor correlation. Lower Î± = smoother but more lag.
                    Default 0.01 (heavy smoothing) is recommended for orientation learning as we only need slow trends.
                  </p>
                </div>
              </div>

              <div className="mt-3 p-3 bg-blue-50 rounded-lg">
                <p className="text-xs text-gray-700">
                  <strong>GPS-Based Calibration:</strong> GPS speed changes automatically detect forward direction. The smoothing parameter controls adaptation rate (higher = more smoothing, slower adaptation). Forward vector updates only when GPS detects meaningful acceleration.
                </p>
              </div>
            </div>

            {/* Step 2: Forward Vector Detection */}
            {calibrationResult && (
              <div className="bg-purple-50 border border-purple-300 rounded-lg p-3 mb-2">
                <h3 className="font-bold text-sm mb-2">Step 2: Forward Vector Detection</h3>
                {(() => {
                  const finalForward = calibrationResult.forwardHistory[calibrationResult.forwardHistory.length - 1];
                  const finalGravity = calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1];

                  const forwardMag = Math.sqrt(finalForward.x**2 + finalForward.y**2 + finalForward.z**2);
                  const gravityMag = Math.sqrt(finalGravity.x**2 + finalGravity.y**2 + finalGravity.z**2);

                  // Check perpendicularity: dot(forward, gravity) should be â‰ˆ 0
                  const dotProduct = (finalForward.x * finalGravity.x +
                                     finalForward.y * finalGravity.y +
                                     finalForward.z * finalGravity.z);
                  const normalizedDot = dotProduct / (forwardMag * gravityMag);
                  const angleDegrees = Math.acos(Math.abs(normalizedDot)) * 180 / Math.PI;

                  // Check if forward is found
                  const forwardPass = forwardMag > 0.5;
                  const perpendicularPass = angleDegrees > 80 && angleDegrees < 100; // Should be ~90Â°

                  return (
                    <div className="text-sm">
                      <div className={`font-bold ${forwardPass ? 'text-green-600' : 'text-red-600'}`}>
                        {forwardPass ? 'âœ… FORWARD VECTOR FOUND' : 'âŒ FORWARD VECTOR WEAK'}
                      </div>
                      <div className="text-xs mt-1">
                        Magnitude: {forwardMag.toFixed(3)} m/sÂ²
                        (target: &gt; 0.5 m/sÂ², current: {forwardPass ? 'PASS' : 'FAIL'})
                      </div>
                      <div className="text-xs">
                        Vector: ({finalForward.x.toFixed(3)}, {finalForward.y.toFixed(3)}, {finalForward.z.toFixed(3)})
                      </div>
                      <div className={`text-xs mt-1 ${perpendicularPass ? 'text-green-600' : 'text-orange-600'}`}>
                        Angle to gravity: {angleDegrees.toFixed(1)}Â°
                        (target: 90Â°, {perpendicularPass ? 'perpendicular âœ“' : 'NOT perpendicular âœ—'})
                      </div>
                      {!forwardPass && (
                        <div className="text-xs mt-2 p-2 bg-yellow-100 border border-yellow-400 rounded">
                          âš ï¸ Forward vector too weak. This causes small x&apos;/y&apos;/z&apos; values.
                          Need more GPS acceleration events or lower filter threshold.
                        </div>
                      )}
                      {!perpendicularPass && (
                        <div className="text-xs mt-2 p-2 bg-orange-100 border border-orange-400 rounded">
                          âš ï¸ Forward not perpendicular to gravity. This causes incorrect transformation.
                          May need to project forward onto horizontal plane.
                        </div>
                      )}
                    </div>
                  );
                })()}
              </div>
            )}


            {/* Master Signal Viewer - Automotive-style comprehensive display */}
            {masterSignalViewerData && (
              <div className="bg-white rounded-lg shadow-lg p-4 mb-6">
                <h2 className="text-xl font-bold mb-3 text-gray-800">
                  ðŸŽ›ï¸ Master Signal Viewer
                </h2>
                <p className="text-sm text-gray-600 mb-3">
                  <strong>Automotive-style multi-signal analysis.</strong> Toggle signals, adjust offsets to align.
                  <strong>Controls:</strong> Drag to scroll | +/âˆ’ buttons to zoom | Mousewheel/trackpad to zoom
                </p>

                {/* Controls - All in one row */}
                <div className="flex flex-wrap gap-4 mb-3 items-center bg-gray-50 p-3 rounded">
                  {/* Zoom Controls */}
                  <div className="flex items-center gap-2">
                    <span className="text-sm font-semibold">Zoom:</span>
                    <button
                      onClick={() => setWindowSize(Math.max(100, windowSize - 100))}
                      className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm"
                    >
                      + In
                    </button>
                    <button
                      onClick={() => setWindowSize(Math.min(totalDataPoints, windowSize + 100))}
                      className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm"
                    >
                      âˆ’ Out
                    </button>
                    <span className="text-xs text-gray-600">{windowSize} pts</span>
                  </div>

                  {/* Presets */}
                  <div className="flex items-center gap-2">
                    <span className="text-sm font-semibold">Presets:</span>
                    <button onClick={() => setWindowSize(200)} className="px-2 py-1 bg-gray-200 rounded text-xs">200</button>
                    <button onClick={() => setWindowSize(500)} className="px-2 py-1 bg-gray-200 rounded text-xs">500</button>
                    <button onClick={() => setWindowSize(1000)} className="px-2 py-1 bg-gray-200 rounded text-xs">1k</button>
                    <button onClick={() => setWindowSize(2000)} className="px-2 py-1 bg-gray-200 rounded text-xs">2k</button>
                    <button onClick={() => setWindowSize(totalDataPoints)} className="px-2 py-1 bg-gray-200 rounded text-xs">All</button>
                  </div>

                  {/* View Mode Toggle */}
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => {
                        setViewMode('all');
                        setScrollPosition(0);
                      }}
                      className={`px-3 py-1 rounded text-sm font-semibold ${
                        viewMode === 'all' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'
                      }`}
                    >
                      All Data
                    </button>
                    <button
                      onClick={() => setViewMode('scrollable')}
                      className={`px-3 py-1 rounded text-sm font-semibold ${
                        viewMode === 'scrollable' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'
                      }`}
                    >
                      Scrollable
                    </button>
                  </div>

                  {/* Filter Strength */}
                  <div className="flex items-center gap-2">
                    <span className="text-sm font-semibold">Filter:</span>
                    <input
                      type="range"
                      min="0.01"
                      max="0.50"
                      step="0.01"
                      value={filterAlpha}
                      onChange={(e) => setFilterAlpha(parseFloat(e.target.value))}
                      className="w-32"
                    />
                    <span className="text-xs text-gray-600">
                      Î±={filterAlpha.toFixed(2)} ({filterAlpha < 0.1 ? 'Heavy' : filterAlpha < 0.3 ? 'Medium' : 'Light'})
                    </span>
                  </div>

                  {/* Observer Filter Strength */}
                  <div className="flex items-center gap-2">
                    <span className="text-sm font-semibold">Observer:</span>
                    <input
                      type="range"
                      min="0.01"
                      max="0.20"
                      step="0.01"
                      value={observerAlpha}
                      onChange={(e) => setObserverAlpha(parseFloat(e.target.value))}
                      className="w-32"
                    />
                    <span className="text-xs text-gray-600">
                      Î±={observerAlpha.toFixed(2)} ({observerAlpha < 0.05 ? 'Max' : observerAlpha < 0.1 ? 'Heavy' : 'Medium'} smoothing)
                    </span>
                  </div>

                  {/* Reset Settings */}
                  <button
                    onClick={() => {
                      localStorage.removeItem('masterSignalViewerControls');
                      window.location.reload();
                    }}
                    className="px-3 py-1 bg-red-600 text-white rounded text-sm hover:bg-red-700"
                  >
                    Reset Settings
                  </button>
                </div>

                {/* Cross-Verification Trifecta Explanation Panel */}
                <div className="bg-blue-50 border border-blue-300 rounded p-3 mb-3 text-xs">
                  <h3 className="font-bold text-sm mb-2">ðŸ”¬ Cross-Verification Trifecta:</h3>

                  <div className="grid grid-cols-3 gap-3">
                    <div>
                      <strong className="text-red-700">LATERAL ACCEL (m/sÂ²):</strong>
                      <ul className="list-disc ml-4 mt-1 space-y-1 text-[10px]">
                        <li><strong>âœ“ accelY_real:</strong> Measured from accelerometer</li>
                        <li><strong>â—‹ accelY_gyro:</strong> Predicted from gyro (v Ã— Ï‰)</li>
                        <li><strong>â—‹ accelY_mag:</strong> Predicted from magnetometer heading rate</li>
                      </ul>
                    </div>

                    <div>
                      <strong className="text-blue-700">ROTATION RATE (rad/s):</strong>
                      <ul className="list-disc ml-4 mt-1 space-y-1 text-[10px]">
                        <li><strong>âœ“ gyroZ_real:</strong> Measured from gyroscope</li>
                        <li><strong>â—‹ gyroZ_accel:</strong> Predicted from accel (a/v)</li>
                        <li><strong>â—‹ gyroZ_mag:</strong> Predicted from heading change</li>
                      </ul>
                    </div>

                    <div>
                      <strong className="text-purple-700">HEADING (degrees):</strong>
                      <ul className="list-disc ml-4 mt-1 space-y-1 text-[10px]">
                        <li><strong>âœ“ heading_real:</strong> Measured from magnetometer</li>
                        <li><strong>â—‹ heading_accel:</strong> Integrated from accel</li>
                        <li><strong>â—‹ heading_gyro:</strong> Integrated from gyro</li>
                      </ul>
                    </div>
                  </div>

                  <div className="mt-2 p-2 bg-yellow-50 border border-yellow-300 rounded text-[10px]">
                    <strong>ðŸ’¡ Key Concept:</strong> Each sensor is verified by the other two.
                    During turns (datapoints 2800-3400), all three lateral accel signals should converge!
                    <strong className="text-red-600"> If they don&apos;t agree, there&apos;s a sensor/calibration problem.</strong>
                    This approach validates sensor health through physics-based cross-checks.
                  </div>
                </div>

                {/* Signal Controls Panel - Readable Size with Tall Scroll Box */}
                <div className="grid grid-cols-4 gap-1 mb-2 max-h-64 overflow-y-auto bg-gray-50 p-2 rounded text-xs">
                  {Object.entries(signalControls).map(([key, control]) => (
                    <div key={key} className="flex items-center gap-1 py-1">
                      <input
                        type="checkbox"
                        checked={control.visible}
                        onChange={(e) => setSignalControls(prev => ({
                          ...prev,
                          [key]: { ...prev[key], visible: e.target.checked }
                        }))}
                        className="w-3 h-3"
                      />
                      <div
                        className="w-3 h-3 rounded"
                        style={{ backgroundColor: control.color.replace('rgba', 'rgb').replace(/, 0\.\d+\)/, ')') }}
                      />
                      <span className="text-[10px] min-w-[80px]" title={control.label || key}>
                        {control.label || key}
                      </span>
                      <input
                        type="range"
                        min="-30"
                        max="30"
                        step="1"
                        value={control.offset}
                        onChange={(e) => {
                          const newOffset = parseInt(e.target.value);
                          setSignalControls(prev => ({
                            ...prev,
                            [key]: { ...prev[key], offset: newOffset }
                          }));
                        }}
                        onDoubleClick={() => {
                          setSignalControls(prev => ({
                            ...prev,
                            [key]: { ...prev[key], offset: 0 }
                          }));
                        }}
                        className="w-32"
                        style={{ height: '4px' }}
                        title={`Offset: ${control.offset} (double-click to reset)`}
                      />
                      <span className="text-[10px] font-semibold text-gray-700 w-6 text-right">
                        {control.offset}
                      </span>
                    </div>
                  ))}
                </div>

                {/* Interactive Chart with drag/zoom */}
                <div
                  onMouseDown={handleMouseDown}
                  onMouseMove={handleMouseMove}
                  onMouseUp={handleMouseUp}
                  onMouseLeave={handleMouseUp}
                  onWheel={handleWheel}
                  style={{
                    height: '1200px',
                    cursor: isDragging ? 'grabbing' : 'grab',
                    userSelect: 'none'
                  }}
                >
                  <Line
                    data={masterSignalViewerData}
                    options={{
                      responsive: true,
                      maintainAspectRatio: false,
                      animation: false,
                      interaction: {
                        mode: 'index',
                        intersect: false
                      },
                      scales: {
                        x: {
                          display: true,
                          grid: { display: false },
                          title: {
                            display: true,
                            text: viewMode === 'scrollable'
                              ? `Datapoint Index (showing ${scrollPosition} to ${scrollPosition + windowSize})`
                              : 'Datapoint Index (all data)'
                          },
                          ticks: {
                            callback: function(value, index) {
                              const label = this.chart.data.labels?.[index] as string || index.toString();
                              const numValue = parseInt(label);
                              const totalPoints = viewMode === 'all' ? calibrationResult.transformed.length : windowSize;

                              let tickInterval;
                              if (viewMode === 'scrollable') {
                                tickInterval = Math.max(50, Math.floor(windowSize / 5));
                              } else {
                                if (totalPoints < 1000) tickInterval = 200;
                                else if (totalPoints < 3000) tickInterval = 500;
                                else if (totalPoints < 6000) tickInterval = 1000;
                                else tickInterval = 2000;
                              }

                              if (numValue % tickInterval === 0) {
                                if (numValue >= 1000) {
                                  return (numValue / 1000).toFixed(1) + 'k';
                                }
                                return numValue.toString();
                              }
                              return '';
                            },
                            maxRotation: 0,
                            autoSkip: false
                          }
                        },
                        y: {
                          position: 'left',
                          min: -30,
                          max: 30,
                          ticks: {
                            stepSize: 10
                          },
                          title: {
                            display: true,
                            text: 'Acceleration (m/sÂ²) / Rotation (rad/s) / Heading (Â°)'
                          },
                          grid: {
                            color: (context) => {
                              if (context.tick.value === 0) return 'rgba(0, 0, 0, 0.3)';
                              return 'rgba(0, 0, 0, 0.05)';
                            }
                          }
                        },
                        y1: {
                          position: 'right',
                          min: 0,
                          max: 80,
                          title: {
                            display: true,
                            text: 'Speed (mph) / Confidence (%)'
                          },
                          grid: {
                            display: false
                          }
                        }
                      },
                      plugins: {
                        legend: {
                          display: true,
                          position: 'top' as const,
                          labels: {
                            boxWidth: 20,
                            font: { size: 10 },
                            usePointStyle: true,
                            padding: 10
                          }
                        },
                        tooltip: {
                          enabled: true,
                          mode: 'index',
                          intersect: false
                        }
                      }
                    }}
                  />
                </div>

                {/* Instructions */}
                <div className="mt-3 text-xs text-gray-600 bg-blue-50 p-2 rounded">
                  <strong>Controls:</strong> Drag left/right to scroll â€¢ Mouse wheel to zoom in/out â€¢
                  Toggle checkboxes to show/hide signals â€¢ Sliders adjust vertical offset for clarity
                </div>
              </div>
            )}

            {/* Combined Acceleration Analysis Chart */}
            {accelerationAnalysisData && (
              <div className="bg-white rounded-lg shadow-lg p-2 mb-2">
                <h2 className="text-base font-bold mb-1 text-gray-800">
                  ðŸ”¬ Acceleration Analysis: Raw â†’ Linear â†’ GPS Comparison
                </h2>
                <p className="text-xs text-gray-600 mb-2">
                  <strong>THICK colored lines</strong> = Transformed vehicle coordinates (filtered Î±={orientationFilterAlpha.toFixed(3)}).
                  ðŸŸ¢ GPS ground truth | ðŸ”´ Red x&apos; (accel/brake) | ðŸ”µ Blue y&apos; (turn) | ðŸŸ© Green z&apos; (bump).
                  <strong>If orientation is correct, x&apos;/y&apos;/z&apos; should oscillate around ZERO during cruise.</strong>
                  Orange dashed = sensor magnitude in phone coords (for comparison).
                </p>
                <div key={`accel-analysis-${scrollPosition}-${viewMode}-${orientationFilterAlpha}`} style={{ height: '500px' }}>
                  <Line
                    data={accelerationAnalysisData}
                    options={{
                      responsive: true,
                      maintainAspectRatio: false,
                      animation: false,
                      scales: {
                        x: {
                          display: true,
                          grid: { display: false },
                          ticks: {
                            callback: function(value, index) {
                              const label = this.chart.data.labels?.[index] as string || index.toString();
                              const numValue = parseInt(label);
                              const totalPoints = viewMode === 'all' ? totalDataPoints : windowSize;

                              let tickInterval;
                              if (viewMode === 'scrollable') {
                                tickInterval = Math.max(50, Math.floor(windowSize / 5));
                              } else {
                                if (totalPoints < 1000) tickInterval = 200;
                                else if (totalPoints < 3000) tickInterval = 500;
                                else if (totalPoints < 6000) tickInterval = 1000;
                                else tickInterval = 2000;
                              }

                              if (numValue % tickInterval === 0) {
                                if (numValue >= 1000) {
                                  return (numValue / 1000).toFixed(1) + 'k';
                                }
                                return numValue.toString();
                              }
                              return '';
                            },
                            maxRotation: 0,
                            autoSkip: false
                          }
                        },
                        y: {
                          min: -10,
                          max: 10,
                          ticks: {
                            stepSize: 5,
                            font: { size: 11 }
                          },
                          grid: { color: 'rgba(0, 0, 0, 0.05)' },
                          title: {
                            display: true,
                            text: 'Acceleration (m/sÂ²)',
                            font: { size: 12, weight: 'bold' }
                          }
                        }
                      },
                      plugins: {
                        legend: {
                          display: true,
                          position: 'top' as const,
                          labels: {
                            boxWidth: 20,
                            font: { size: 11 },
                            usePointStyle: true,
                            padding: 15
                          }
                        }
                      }
                    }}
                  />
                </div>
                <div className="mt-2 text-xs text-gray-600">
                  <strong>âœ… Orientation Test:</strong> During constant-speed cruise, x&apos;/y&apos;/z&apos; should be near zero.
                  If x&apos; matches GPS spikes (accel/brake) and y&apos; shows turns â†’ orientation is CORRECT!
                  Phone-coordinate lines (faded) are for reference only.
                </div>
              </div>
            )}

            {/* Vehicle Reference Frame (KEY CHART) - MOST IMPORTANT! */}
            {referenceFrameChartData && (
              <div className="bg-white rounded-lg shadow-lg p-2 mb-2 border-4 border-blue-300">
                <div className="flex items-center gap-2 mb-2">
                  <h2 className="text-2xl font-bold text-gray-800">
                    ðŸ“ Vehicle Reference Frame {viewMode === 'scrollable' && `(showing ${scrollPosition} to ${scrollPosition + windowSize})`}
                  </h2>
                  <span className="px-3 py-1 bg-gradient-to-r from-blue-500 to-indigo-600 text-white text-xs font-bold rounded-full">
                    ðŸŽ¯ KEY RESULT
                  </span>
                </div>
                <p className="text-xs text-gray-600 mb-2">
                  Transformed vehicle coordinates (xâ€², yâ€², zâ€²) with zero baseline - this is what actually matters!
                </p>

                {avgConfidence > 0.8 && (
                  <div className="mb-3 p-2 bg-green-100 border border-green-400 rounded-lg">
                    <div className="text-green-800 text-sm font-semibold">
                      âœ“ Reference frame stabilized - vehicle coordinates established
                    </div>
                  </div>
                )}

                <div key={`vrf-${scrollPosition}-${viewMode}`} style={{ height: '200px', backgroundColor: '#ffffff' }}>
                  <Line
                    data={referenceFrameChartData}
                    options={{
                      responsive: true,
                      maintainAspectRatio: false,
                      animation: false,
                      backgroundColor: '#ffffff',
                      scales: {
                        x: {
                          display: true,
                          grid: {
                            display: false  // REMOVE vertical grid lines
                          },
                          ticks: {
                            callback: function(value, index) {
                              // Read from labels array - these are the actual datapoint numbers!
                              const label = this.chart.data.labels?.[index] as string || index.toString();
                              const numValue = parseInt(label);

                              const totalPoints = viewMode === 'all' ? totalDataPoints : windowSize;

                              // AGGRESSIVE tick spacing (5-10 ticks max)
                              let tickInterval;
                              if (viewMode === 'scrollable') {
                                tickInterval = Math.max(50, Math.floor(windowSize / 5)); // 5 ticks in scroll
                              } else {
                                // All data mode: MUCH more aggressive
                                if (totalPoints < 1000) {
                                  tickInterval = 200;    // 5 ticks for <1k
                                } else if (totalPoints < 3000) {
                                  tickInterval = 500;    // 6 ticks for 1k-3k
                                } else if (totalPoints < 6000) {
                                  tickInterval = 1000;   // 6 ticks for 3k-6k
                                } else {
                                  tickInterval = 2000;   // 5 ticks for 6k+
                                }
                              }

                              if (numValue % tickInterval === 0) {
                                if (numValue >= 1000) {
                                  return (numValue / 1000).toFixed(1) + 'k';
                                }
                                return numValue.toString();
                              }
                              return '';
                            },
                            maxRotation: 0,
                            autoSkip: false
                          }
                        },
                        y: {
                          min: -10,
                          max: 10,
                          grid: {
                            color: '#e5e7eb',  // Very light gray
                            lineWidth: 1
                          },
                          ticks: { stepSize: 5 }
                        }
                      },
                      plugins: {
                        legend: {
                          display: true,
                          position: 'top' as const,
                        },
                        tooltip: {
                          callbacks: {
                            label: (context) => {
                              const value = context.parsed.y;
                              return `${context.dataset.label}: ${value !== null ? value.toFixed(2) : '0.00'} m/sÂ²`;
                            }
                          }
                        }
                      }
                    }}
                  />
                </div>

                <div className="mt-3 p-3 bg-blue-50 rounded-lg">
                  <h3 className="font-bold text-gray-800 text-sm mb-2">âœ“ Calibration Success Indicators:</h3>
                  <ul className="list-disc list-inside space-y-1 text-xs text-gray-700">
                    <li>
                      <strong className="text-red-600">xâ€²</strong> oscillates around zero = forward/back acceleration only
                    </li>
                    <li>
                      <strong className="text-blue-600">yâ€²</strong> oscillates around zero = lateral (turning) forces only
                    </li>
                    <li>
                      <strong className="text-green-600">zâ€²</strong> oscillates around zero = vertical (bumps) forces only
                    </li>
                    <li>Gravity component removed - all axes centered near the gray zero baseline</li>
                  </ul>
                </div>
              </div>
            )}

            {/* Step 1: Gravity Detection Indicator */}
            {calibrationResult && (
              <div className="bg-blue-50 border border-blue-300 rounded-lg p-3 mb-2">
                <h3 className="font-bold text-sm mb-2">Step 1: Gravity Detection</h3>
                {(() => {
                  const finalGravity = calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1];
                  const gravityMag = Math.sqrt(finalGravity.x**2 + finalGravity.y**2 + finalGravity.z**2);
                  const gravityError = Math.abs((gravityMag - 9.8) / 9.8 * 100);
                  const gravityPass = gravityError < 5;

                  return (
                    <div className="text-sm">
                      <div className={`font-bold ${gravityPass ? 'text-green-600' : 'text-red-600'}`}>
                        {gravityPass ? 'âœ… GRAVITY FOUND' : 'âŒ GRAVITY NOT FOUND'}
                      </div>
                      <div className="text-xs mt-1">
                        Magnitude: {gravityMag.toFixed(2)} m/sÂ²
                        (target: 9.80 m/sÂ², error: {gravityError.toFixed(1)}%)
                      </div>
                      <div className="text-xs">
                        Vector: ({finalGravity.x.toFixed(2)}, {finalGravity.y.toFixed(2)}, {finalGravity.z.toFixed(2)})
                      </div>
                    </div>
                  );
                })()}
              </div>
            )}

            {/* Gravity Convergence Chart */}
            {gravityMagnitudeData && (
              <div className="bg-white rounded-lg shadow-lg p-2 mb-2">
                <h2 className="text-base font-bold mb-1 text-gray-800">
                  ðŸ“ˆ Step 1: Gravity Magnitude Convergence
                </h2>
                <p className="text-xs text-gray-600 mb-2">
                  Shows how gravity magnitude converges to 9.8 m/sÂ² over time. Should stabilize within first 5 seconds (~300 samples).
                </p>
                <div key={`gravity-mag-${scrollPosition}-${viewMode}`} style={{ height: '150px' }}>
                  <Line
                    data={gravityMagnitudeData}
                    options={{
                      responsive: true,
                      maintainAspectRatio: false,
                      animation: false,
                      scales: {
                        x: {
                          display: true,
                          grid: { display: false },
                          ticks: {
                            callback: function(value, index) {
                              const label = this.chart.data.labels?.[index] as string || index.toString();
                              const numValue = parseInt(label);
                              const totalPoints = viewMode === 'all' ? totalDataPoints : windowSize;

                              let tickInterval;
                              if (viewMode === 'scrollable') {
                                tickInterval = Math.max(50, Math.floor(windowSize / 5));
                              } else {
                                if (totalPoints < 1000) tickInterval = 200;
                                else if (totalPoints < 3000) tickInterval = 500;
                                else if (totalPoints < 6000) tickInterval = 1000;
                                else tickInterval = 2000;
                              }

                              if (numValue % tickInterval === 0) {
                                if (numValue >= 1000) {
                                  return (numValue / 1000).toFixed(1) + 'k';
                                }
                                return numValue.toString();
                              }
                              return '';
                            },
                            maxRotation: 0,
                            autoSkip: false
                          }
                        },
                        y: {
                          min: 0,
                          max: 12,
                          ticks: { stepSize: 2 },
                          title: {
                            display: true,
                            text: 'Magnitude (m/sÂ²)'
                          }
                        }
                      },
                      plugins: {
                        legend: { display: true, position: 'top' as const }
                      }
                    }}
                  />
                </div>
                <div className="mt-2 text-xs text-gray-600">
                  Green line = actual gravity magnitude | Red dashed line = target (9.8 m/sÂ²)
                </div>
              </div>
            )}

            {/* Calibration State Timeline */}
            {stateTimelineData && calibrationResult && (
              <div className="bg-white rounded-lg shadow-lg p-2 mb-2">
                <div className="flex justify-between items-center mb-1">
                  <h2 className="text-xl font-bold text-gray-800">
                    ðŸ“Š Calibration State Timeline {viewMode === 'scrollable' && `(showing ${scrollPosition} to ${scrollPosition + windowSize})`}
                  </h2>
                  <button
                    onClick={() => setCollapsedCharts(prev => ({ ...prev, stateTimeline: !prev.stateTimeline }))}
                    className="text-sm px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                  >
                    {collapsedCharts.stateTimeline ? 'â–¶ Show' : 'â–¼ Hide'}
                  </button>
                </div>
                {!collapsedCharts.stateTimeline && (
                  <>
                    <p className="text-xs text-gray-600 mb-2">
                      Visual timeline showing when conditions are met for forward vector updates
                    </p>
                    <div key={`timeline-${scrollPosition}-${viewMode}`} style={{ height: '100px', backgroundColor: '#ffffff' }}>
                      <Line
                        data={stateTimelineData}
                        options={{
                          responsive: true,
                          maintainAspectRatio: false,
                          animation: false,
                          backgroundColor: '#ffffff',
                          scales: {
                            x: {
                              display: true,
                              grid: {
                                display: false  // REMOVE vertical grid lines
                              },
                              ticks: {
                                callback: function(value, index) {
                                  // Read from labels array - these are the actual datapoint numbers!
                                  const label = this.chart.data.labels?.[index] as string || index.toString();
                                  const numValue = parseInt(label);
                                  const totalPoints = viewMode === 'all' ? totalDataPoints : windowSize;

                                  // AGGRESSIVE tick spacing (5-10 ticks max)
                                  let tickInterval;
                                  if (viewMode === 'scrollable') {
                                    tickInterval = Math.max(50, Math.floor(windowSize / 5)); // 5 ticks in scroll
                                  } else {
                                    // All data mode: MUCH more aggressive
                                    if (totalPoints < 1000) {
                                      tickInterval = 200;    // 5 ticks for <1k
                                    } else if (totalPoints < 3000) {
                                      tickInterval = 500;    // 6 ticks for 1k-3k
                                    } else if (totalPoints < 6000) {
                                      tickInterval = 1000;   // 6 ticks for 3k-6k
                                    } else {
                                      tickInterval = 2000;   // 5 ticks for 6k+
                                    }
                                  }

                                  if (numValue % tickInterval === 0) {
                                    if (numValue >= 1000) {
                                      return (numValue / 1000).toFixed(1) + 'k';
                                    }
                                    return numValue.toString();
                                  }
                                  return '';
                                },
                                maxRotation: 0,
                                autoSkip: false
                              }
                            },
                            y: {
                              min: 0,
                              max: 2.0,
                              display: false
                            }
                          },
                          plugins: {
                            legend: {
                              display: true,
                              position: 'top' as const
                            }
                          }
                        }}
                      />
                    </div>
                    <div className="mt-3 text-xs text-gray-600">
                      GPS Accel Detected: {calibrationResult.gpsAccelDetected.filter(v => v).length}/{calibrationResult.gpsAccelDetected.length} samples |
                      Turning Detected: {calibrationResult.turningDetected.filter(v => v).length}/{calibrationResult.turningDetected.length} samples |
                      Forward Updates: {calibrationResult.forwardUpdateCount[calibrationResult.forwardUpdateCount.length - 1]} total
                    </div>
                  </>
                )}
              </div>
            )}

            {/* Virtual vs Real Acceleration Comparison */}
            {virtualVsRealData && (
              <div className="bg-white rounded-lg shadow-lg p-2 mb-2">
                <div className="flex justify-between items-center mb-1">
                  <h2 className="text-xl font-bold text-gray-800">
                    ðŸŽ¯ Virtual vs Real Acceleration {viewMode === 'scrollable' && `(showing ${scrollPosition} to ${scrollPosition + windowSize})`}
                  </h2>
                  <button
                    onClick={() => setCollapsedCharts(prev => ({ ...prev, virtualVsReal: !prev.virtualVsReal }))}
                    className="text-sm px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                  >
                    {collapsedCharts.virtualVsReal ? 'â–¶ Show' : 'â–¼ Hide'}
                  </button>
                </div>
                {!collapsedCharts.virtualVsReal && (
                  <>
                    <p className="text-xs text-gray-600 mb-2">
                      GPS-derived virtual acceleration (ground truth) vs sensor-measured acceleration. Good correlation confirms calibration.
                    </p>
                    <div key={`virtual-${scrollPosition}-${viewMode}`} style={{ height: '150px', backgroundColor: '#ffffff' }}>
                      <Line
                        data={virtualVsRealData}
                        options={{
                          responsive: true,
                          maintainAspectRatio: false,
                          animation: false,
                          backgroundColor: '#ffffff',
                          scales: {
                            x: {
                              display: true,
                              grid: {
                                display: false  // REMOVE vertical grid lines
                              },
                              ticks: {
                                callback: function(value, index) {
                                  // Read from labels array - these are the actual datapoint numbers!
                                  const label = this.chart.data.labels?.[index] as string || index.toString();
                                  const numValue = parseInt(label);
                                  const totalPoints = viewMode === 'all' ? totalDataPoints : windowSize;

                                  // AGGRESSIVE tick spacing (5-10 ticks max)
                                  let tickInterval;
                                  if (viewMode === 'scrollable') {
                                    tickInterval = Math.max(50, Math.floor(windowSize / 5)); // 5 ticks in scroll
                                  } else {
                                    // All data mode: MUCH more aggressive
                                    if (totalPoints < 1000) {
                                      tickInterval = 200;    // 5 ticks for <1k
                                    } else if (totalPoints < 3000) {
                                      tickInterval = 500;    // 6 ticks for 1k-3k
                                    } else if (totalPoints < 6000) {
                                      tickInterval = 1000;   // 6 ticks for 3k-6k
                                    } else {
                                      tickInterval = 2000;   // 5 ticks for 6k+
                                    }
                                  }

                                  if (numValue % tickInterval === 0) {
                                    if (numValue >= 1000) {
                                      return (numValue / 1000).toFixed(1) + 'k';
                                    }
                                    return numValue.toString();
                                  }
                                  return '';
                                },
                                maxRotation: 0,
                                autoSkip: false
                              }
                            },
                            y: {
                              min: -5,
                              max: 5,
                              grid: {
                                color: '#e5e7eb',  // Very light gray
                                lineWidth: 1
                              },
                              ticks: { stepSize: 2 }
                            }
                          },
                          plugins: {
                            legend: { display: true, position: 'top' as const }
                          }
                        }}
                      />
                    </div>
                    <div className="mt-3 text-xs text-gray-600">
                      Green line = GPS-based virtual acceleration | Red line = Sensor-measured acceleration
                    </div>
                  </>
                )}
              </div>
            )}

            {/* Chart 1: Calibration Progress & Speed */}
            {confidenceChartData && (
              <div className="bg-white rounded-lg shadow-lg p-2 mb-2">
                <h2 className="text-base font-bold mb-1 text-gray-800">
                  ðŸ“Š Calibration Progress & Vehicle Speed {viewMode === 'scrollable' && `(showing ${scrollPosition} to ${scrollPosition + windowSize})`}
                </h2>
                <p className="text-xs text-gray-600 mb-2">
                  Confidence level (left axis) and GPS speed (right axis) over time
                </p>
                <div key={`progress-${scrollPosition}-${viewMode}`} style={{ height: '120px', backgroundColor: '#ffffff' }}>
                  <Line
                    data={confidenceChartData}
                    options={{
                      responsive: true,
                      maintainAspectRatio: false,
                      animation: false,
                      backgroundColor: '#ffffff',
                      scales: {
                        x: {
                          display: true,
                          grid: {
                            display: false  // REMOVE vertical grid lines
                          },
                          ticks: {
                            callback: function(value, index) {
                              // Read from labels array - these are the actual datapoint numbers!
                              const label = this.chart.data.labels?.[index] as string || index.toString();
                              const numValue = parseInt(label);

                              const totalPoints = viewMode === 'all' ? totalDataPoints : windowSize;

                              let tickInterval;
                              if (viewMode === 'scrollable') {
                                tickInterval = Math.max(50, Math.floor(windowSize / 5));
                              } else {
                                if (totalPoints < 1000) tickInterval = 200;
                                else if (totalPoints < 3000) tickInterval = 500;
                                else if (totalPoints < 6000) tickInterval = 1000;
                                else tickInterval = 2000;
                              }

                              if (numValue % tickInterval === 0) {
                                if (numValue >= 1000) {
                                  return (numValue / 1000).toFixed(1) + 'k';
                                }
                                return numValue.toString();
                              }
                              return '';
                            },
                            maxRotation: 0,
                            autoSkip: false
                          }
                        },
                        y: {
                          type: 'linear',
                          display: true,
                          position: 'left',
                          min: 0,
                          max: 100,
                          grid: {
                            color: '#e5e7eb',  // Very light gray
                            lineWidth: 1
                          },
                          ticks: {
                            stepSize: 25,
                            callback: function(value) {
                              return value + '%';
                            }
                          },
                          title: {
                            display: true,
                            text: 'Confidence (%)',
                            color: '#10b981'
                          }
                        },
                        y1: {
                          type: 'linear',
                          display: true,
                          position: 'right',
                          min: 0,
                          max: 80,
                          ticks: {
                            stepSize: 20,
                            callback: function(value) {
                              return value + ' mph';
                            }
                          },
                          title: {
                            display: true,
                            text: 'Speed (mph)',
                            color: '#8b5cf6'
                          },
                          grid: {
                            display: false  // Don't draw grid lines for right axis
                          }
                        }
                      },
                      plugins: {
                        legend: { display: true, position: 'top' as const }
                      }
                    }}
                  />
                </div>
              </div>
            )}


            {/* Chart: Raw Sensor Vectors (Phone Coordinates) */}
            {gravityForwardChartData && calibrationResult && (
              <div className="bg-white rounded-lg shadow-lg p-2 mb-2">
                <h2 className="text-base font-bold mb-1 text-gray-800">
                  ðŸ“± Raw Sensor Vectors (Phone Coordinates) {viewMode === 'scrollable' && `(showing ${scrollPosition} to ${scrollPosition + windowSize})`}
                </h2>
                <p className="text-xs text-gray-600 mb-2">
                  Shows gravity and forward in phone's coordinate system. Solid lines: Gravity | Dashed lines: Forward (motion direction)
                </p>
                <div key={`raw-${scrollPosition}-${viewMode}`} style={{ height: '150px', backgroundColor: '#ffffff' }}>
                  <Line
                    data={gravityForwardChartData}
                    options={{
                      responsive: true,
                      maintainAspectRatio: false,
                      animation: false,
                      backgroundColor: '#ffffff',
                      scales: {
                        x: {
                          display: true,
                          grid: {
                            display: false  // REMOVE vertical grid lines
                          },
                          ticks: {
                            callback: function(value, index) {
                              // Read from labels array - these are the actual datapoint numbers!
                              const label = this.chart.data.labels?.[index] as string || index.toString();
                              const numValue = parseInt(label);

                              const totalPoints = viewMode === 'all' ? totalDataPoints : windowSize;

                              // AGGRESSIVE tick spacing (5-10 ticks max)
                              let tickInterval;
                              if (viewMode === 'scrollable') {
                                tickInterval = Math.max(50, Math.floor(windowSize / 5)); // 5 ticks in scroll
                              } else {
                                // All data mode: MUCH more aggressive
                                if (totalPoints < 1000) {
                                  tickInterval = 200;    // 5 ticks for <1k
                                } else if (totalPoints < 3000) {
                                  tickInterval = 500;    // 6 ticks for 1k-3k
                                } else if (totalPoints < 6000) {
                                  tickInterval = 1000;   // 6 ticks for 3k-6k
                                } else {
                                  tickInterval = 2000;   // 5 ticks for 6k+
                                }
                              }

                              if (numValue % tickInterval === 0) {
                                if (numValue >= 1000) {
                                  return (numValue / 1000).toFixed(1) + 'k';
                                }
                                return numValue.toString();
                              }
                              return '';
                            },
                            maxRotation: 0,
                            autoSkip: false
                          }
                        },
                        y: {
                          min: -12,
                          max: 12,
                          grid: {
                            color: '#e5e7eb',  // Very light gray
                            lineWidth: 1
                          },
                          ticks: { stepSize: 4 }
                        }
                      },
                      plugins: {
                        legend: {
                          display: true,
                          position: 'top' as const,
                        },
                        tooltip: {
                          callbacks: {
                            label: (context) => {
                              const value = context.parsed.y;
                              return `${context.dataset.label}: ${value !== null ? value.toFixed(2) : '0.00'} m/sÂ²`;
                            }
                          }
                        }
                      }
                    }}
                  />
                </div>
                <div className="mt-3 text-xs text-gray-600">
                  {(() => {
                    const lastGravity = calibrationResult.gravityHistory[calibrationResult.gravityHistory.length - 1];
                    if (!lastGravity) return null;
                    const gravityMag = Math.sqrt(lastGravity.x ** 2 + lastGravity.y ** 2 + lastGravity.z ** 2);
                    return (
                      <span>
                        Gravity Magnitude: <strong>{gravityMag.toFixed(2)} m/sÂ²</strong> (target: 9.8 m/sÂ²)
                      </span>
                    );
                  })()}
                </div>
              </div>
            )}

            {/* Analysis Info */}
            <div className="bg-white rounded-lg shadow-lg p-4 mt-4">
              <h2 className="text-base font-bold mb-2">About Gyro-Gated Calibration</h2>
              <ul className="list-disc list-inside space-y-1 text-xs text-gray-700">
                <li>
                  <strong>Gyro-Gated Learning:</strong> Forward vector only updates during straight-line motion (gyro &lt; 1.5 rad/s / ~86Â°/s)
                </li>
                <li>
                  <strong>Phone Stability Check:</strong> Heading must be stable OR magnetometer unreliable to prevent interference
                </li>
                <li>
                  <strong>Gravity Estimation:</strong> Always tracks "down" direction using exponential moving average
                </li>
                <li>
                  <strong>Forward Detection:</strong> Only learns from meaningful acceleration events (&gt; 0.5 m/sÂ²) during straight driving
                </li>
                <li>
                  <strong>4-Factor Confidence:</strong> Gravity quality + Forward quality + Gyro stability + Forward update count (â‰¥20)
                </li>
                <li>
                  <strong>Coordinate Transform:</strong> Projects sensor data onto vehicle axes (forward, lateral, vertical)
                </li>
              </ul>
            </div>
          </>
        ) : (
          <div className="bg-white rounded-lg shadow-lg p-6">
            <div className="text-center text-gray-600">Session not found.</div>
          </div>
        )}
      </div>
    </div>
  );
}
